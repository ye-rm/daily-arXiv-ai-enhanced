{"id": "2511.13727", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.13727", "abs": "https://arxiv.org/abs/2511.13727", "authors": ["Sophie Wenning"], "title": "Boosting performance: Gradient Clock Synchronisation with two-way measured links", "comment": "Master's thesis", "summary": "This master thesis extends the formal model of the GCS algorithm as presented by (Fan and Lynch 2004, 325), (Lenzen, Locher and Wattenhofer 2008, 510) and (F\u00fcgger et al. 2023) to operate under implementation-near assumptions by replacing the one-way measurement paradigm assumed in prior work by the two-way measurement paradigm. With this change of paradigm, we remove many restrictions previously enforced to allow provable performance. Most notability, while maintaining the core behaviour of GCS, we: 1. Lift the requirement for unitary link lengths and thereby create a realistic model for flexible deployment of implementations of GCS in practice. 2. Provide a formal model of frequency sources assumed in prior work. 3. Perform a fine grained distinction between the different components of the algorithm's estimation error and globally reduce its impact by multiple orders of magnitude. 4. Significantly reduce the contribution of the uncertainty to the algorithm's estimation error to be in the range of 10\\% to 0,1\\% of the delay per link instead of being in the oder of the delay per link as in prior work and show matching upper bounds on the local and global skew of GCS.", "AI": {"tldr": "This thesis extends the GCS algorithm model to use two-way measurements instead of one-way, removing restrictions like unitary link lengths and significantly reducing estimation error by orders of magnitude.", "motivation": "To create a more realistic and practical model for GCS algorithm implementations by replacing the restrictive one-way measurement paradigm with two-way measurements, enabling flexible deployment in real-world scenarios.", "method": "Extended the formal GCS algorithm model by replacing one-way measurement paradigm with two-way measurement paradigm, providing formal frequency source modeling, and performing fine-grained error component analysis.", "result": "Achieved significant improvements: lifted unitary link length requirement, reduced estimation error impact by multiple orders of magnitude, decreased uncertainty contribution from delay-per-link range to 10%-0.1% of delay per link, and established matching upper bounds on local and global skew.", "conclusion": "The two-way measurement paradigm enables a more practical GCS algorithm model with dramatically improved performance characteristics while maintaining core behavior, making it suitable for real-world implementation."}}
{"id": "2511.13728", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.13728", "abs": "https://arxiv.org/abs/2511.13728", "authors": ["Maximilian Reisecker", "Cynthia Marcelino", "Thomas Pusztai", "Stefan Nastic"], "title": "Gaia: Hybrid Hardware Acceleration for Serverless AI in the 3D Compute Continuum", "comment": "In IEEE ACM 12th International Conference on Big Data Computing, Applications and Technologies (BDCAT 25), 2025, Nantes, France", "summary": "Serverless computing offers elastic scaling and pay-per-use execution, making it well-suited for AI workloads. As these workloads run in heterogeneous environments such as the Edge-Cloud-Space 3D Continuum, they often require intensive parallel computation, which GPUs can perform far more efficiently than CPUs. However, current platforms struggle to manage hardware acceleration effectively, as static user-device assignments fail to ensure SLO compliance under varying loads or placements, and one-time dynamic selections often lead to suboptimal or cost-inefficient configurations. To address these issues, we present Gaia, a GPU-as-a-service model and architecture that makes hardware acceleration a platform concern. Gaia combines (i) a lightweight Execution Mode Identifier that inspects function code at deploy time to emit one of four execution modes, and a Dynamic Function Runtime that continuously reevaluates user-defined SLOs to promote or demote between CPU- and GPU backends. Our evaluation shows that it seamlessly selects the best hardware acceleration for the workload, reducing end-to-end latency by up to 95%. These results indicate that Gaia enables SLO-aware, cost-efficient acceleration for serverless AI across heterogeneous environments.", "AI": {"tldr": "Gaia is a GPU-as-a-service architecture that dynamically selects optimal hardware acceleration (CPU/GPU) for serverless AI workloads across heterogeneous environments, reducing latency by up to 95% while ensuring SLO compliance.", "motivation": "Current serverless platforms struggle with effective hardware acceleration management for AI workloads in heterogeneous Edge-Cloud-Space environments, as static device assignments fail under varying loads and dynamic selections often lead to suboptimal configurations.", "method": "Gaia combines a lightweight Execution Mode Identifier that analyzes function code at deploy time to determine execution modes, and a Dynamic Function Runtime that continuously reevaluates user-defined SLOs to dynamically switch between CPU and GPU backends.", "result": "Evaluation shows Gaia seamlessly selects the best hardware acceleration for workloads, reducing end-to-end latency by up to 95% compared to existing approaches.", "conclusion": "Gaia enables SLO-aware, cost-efficient acceleration for serverless AI across heterogeneous environments by making hardware acceleration a platform concern rather than a static user decision."}}
{"id": "2511.13738", "categories": ["cs.DC", "cs.AR"], "pdf": "https://arxiv.org/pdf/2511.13738", "abs": "https://arxiv.org/abs/2511.13738", "authors": ["Hyunseok Kwak", "Kyeongwon Lee", "Kyeongpil Min", "Chaebin Jung", "Woojoo Lee"], "title": "TT-Edge: A Hardware-Software Co-Design for Energy-Efficient Tensor-Train Decomposition on Edge AI", "comment": "8 pages, 6 figures, 4 Tables, DATE 2026 accepted paper", "summary": "The growing demands of distributed learning on resource constrained edge devices underscore the importance of efficient on device model compression. Tensor Train Decomposition (TTD) offers high compression ratios with minimal accuracy loss, yet repeated singular value decompositions (SVDs) and matrix multiplications can impose significant latency and energy costs on low power processors. In this work, we present TT-Edge, a hardware software co designed framework aimed at overcoming these challenges. By splitting SVD into two phases--bidiagonalization and diagonalization--TT-Edge offloads the most compute intensive tasks to a specialized TTD Engine. This engine integrates tightly with an existing GEMM accelerator, thereby curtailing the frequent matrix vector transfers that often undermine system performance and energy efficiency. Implemented on a RISC-V-based edge AI processor, TT-Edge achieves a 1.7x speedup compared to a GEMM only baseline when compressing a ResNet 32 model via TTD, while reducing overall energy usage by 40.2 percent. These gains come with only a 4 percent increase in total power and minimal hardware overhead, enabled by a lightweight design that reuses GEMM resources and employs a shared floating point unit. Our experimental results on both FPGA prototypes and post-synthesis power analysis at 45 nm demonstrate that TT-Edge effectively addresses the latency and energy bottlenecks of TTD based compression in edge environments.", "AI": {"tldr": "TT-Edge is a hardware-software co-designed framework that accelerates Tensor Train Decomposition (TTD) for on-device model compression by offloading compute-intensive SVD operations to a specialized TTD Engine integrated with existing GEMM accelerators.", "motivation": "The growing demands of distributed learning on resource-constrained edge devices require efficient model compression, but TTD's repeated SVDs and matrix multiplications impose significant latency and energy costs on low-power processors.", "method": "TT-Edge splits SVD into bidiagonalization and diagonalization phases, offloading compute-intensive tasks to a specialized TTD Engine that integrates with existing GEMM accelerators to reduce matrix-vector transfers. Implemented on RISC-V edge AI processor with lightweight design reusing GEMM resources and shared floating point unit.", "result": "Achieves 1.7x speedup compared to GEMM-only baseline when compressing ResNet-32 via TTD, reduces overall energy usage by 40.2% with only 4% increase in total power and minimal hardware overhead.", "conclusion": "TT-Edge effectively addresses latency and energy bottlenecks of TTD-based compression in edge environments, as demonstrated by FPGA prototypes and post-synthesis power analysis at 45nm."}}
{"id": "2511.13751", "categories": ["cs.DC", "cs.AR", "cs.PL"], "pdf": "https://arxiv.org/pdf/2511.13751", "abs": "https://arxiv.org/abs/2511.13751", "authors": ["Shinnung Jeong", "Chihyo Ahn", "Huanzhi Pu", "Jisheng Zhao", "Hyesoon Kim", "Blaise Tine"], "title": "Inside VOLT: Designing an Open-Source GPU Compiler", "comment": "11 pages, 10 figures, two tables, two algorithms", "summary": "Recent efforts in open-source GPU research are opening new avenues in a domain that has long been tightly coupled with a few commercial vendors. Emerging open GPU architectures define SIMT functionality through their own ISAs, but executing existing GPU programs and optimizing performance on these ISAs relies on a compiler framework that is technically complex and often undercounted in open hardware development costs.\n  To address this challenge, the Vortex-Optimized Lightweight Toolchain (VOLT) has been proposed. This paper presents its design principles, overall structure, and the key compiler transformations required to support SIMT execution on Vortex. VOLT enables SIMT code generation and optimization across multiple levels of abstraction through a hierarchical design that accommodates diverse front-end languages and open GPU hardware. To ensure extensibility as GPU architectures evolve, VOLT centralizes fundamental SIMT-related analyses and optimizations in the middle-end, allowing them to be reused across front-ends and easily adapted to emerging open-GPU variants. Through two case studies on ISA extensions and host-runtime API, this paper also demonstrates how VOLT can support extensions", "AI": {"tldr": "VOLT is a lightweight compiler toolchain designed to support SIMT execution on open GPU architectures like Vortex, addressing the complexity of compiling existing GPU programs for emerging open GPU ISAs.", "motivation": "Open-source GPU research is growing but faces challenges in executing existing GPU programs on new open GPU architectures due to complex compiler frameworks that are often underestimated in development costs.", "method": "VOLT uses a hierarchical design with centralized SIMT analyses and optimizations in the middle-end, enabling code generation across multiple abstraction levels and supporting diverse front-end languages and open GPU hardware.", "result": "VOLT successfully enables SIMT code generation and optimization, and through case studies demonstrates support for ISA extensions and host-runtime API extensions.", "conclusion": "VOLT provides an extensible compiler framework that can adapt to evolving open GPU architectures while reusing fundamental SIMT optimizations across different front-ends and hardware variants."}}
{"id": "2511.14296", "categories": ["cs.ET", "cs.DM", "physics.app-ph", "quant-ph"], "pdf": "https://arxiv.org/pdf/2511.14296", "abs": "https://arxiv.org/abs/2511.14296", "authors": ["Chinonso Onah", "Roman Firt", "Kristel Michielsen"], "title": "Empirical Quantum Advantage in Constrained Optimization from Encoded Unitary Designs", "comment": "32 Pages, 5 figures, 2 tables", "summary": "We introduce the Constraint-Enhanced Quantum Approximate Optimization Algorithm (CE-QAOA), a shallow, constraint-aware ansatz that operates inside the one-hot product space of size [n]^m, where m is the number of blocks and each block is initialized with an n-qubit W_n state. We give an ancilla-free, depth-optimal encoder that prepares a W_n state using n-1 two-qubit rotations per block, and a two-local XY mixer restricted to the same block of n qubits with a constant spectral gap. Algorithmically, we wrap constant-depth sampling with a deterministic classical checker to obtain a polynomial-time hybrid quantum-classical solver (PHQC) that returns the best observed feasible solution in O(S n^2) time, where S is the number of shots. We obtain two advantages. First, when CE-QAOA fixes r >= 1 locations different from the start city, we achieve a Theta(n^r) reduction in shot complexity even against a classical sampler that draws uniformly from the feasible set. Second, against a classical baseline restricted to raw bitstring sampling, we show an exp(Theta(n^2)) separation in the minimax sense. In noiseless circuit simulations of TSP instances ranging from 4 to 10 locations from the QOPTLib benchmark library, we recover the global optimum at depth p = 1 using polynomial shot budgets and coarse parameter grids defined by the problem sizes.", "AI": {"tldr": "CE-QAOA is a constraint-aware quantum algorithm that uses W-state encoding and XY mixers to solve optimization problems like TSP with polynomial-time hybrid quantum-classical approach, achieving exponential speedup over classical sampling methods.", "motivation": "To develop a quantum optimization algorithm that efficiently handles constraints while maintaining shallow circuit depth, addressing the challenge of constraint satisfaction in quantum approximate optimization algorithms.", "method": "Uses constraint-aware ansatz with W-state initialization, ancilla-free depth-optimal encoder, two-local XY mixers restricted to blocks, and wraps quantum sampling with classical checker to ensure feasibility.", "result": "Achieves Theta(n^r) reduction in shot complexity and exp(Theta(n^2)) separation from classical sampling baselines. Successfully recovers global optimum for TSP instances (4-10 locations) at depth p=1 with polynomial shot budgets.", "conclusion": "CE-QAOA provides an effective hybrid quantum-classical approach for constrained optimization problems with provable advantages over classical methods and practical performance on benchmark problems."}}
{"id": "2511.13950", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.13950", "abs": "https://arxiv.org/abs/2511.13950", "authors": ["Lei Zhao", "Luca Buonanno", "Archit Gajjar", "John Moon", "Aishwarya Natarajan", "Sergey Serebryakov", "Ron M. Roth", "Xia Sheng", "Youtao Zhang", "Paolo Faraboschi", "Jim Ignowski", "Giacomo Pedretti"], "title": "NL-DPE: An Analog In-memory Non-Linear Dot Product Engine for Efficient CNN and LLM Inference", "comment": null, "summary": "Resistive Random Access Memory (RRAM) based in-memory computing (IMC) accelerators offer significant performance and energy advantages for deep neural networks (DNNs), but face three major limitations: (1) they support only \\textit{static} dot-product operations and cannot accelerate arbitrary non-linear functions or data-dependent multiplications essential to modern LLMs; (2) they demand large, power-hungry analog-to-digital converter (ADC) circuits; and (3) mapping model weights to device conductance introduces errors from cell nonidealities. These challenges hinder scalable and accurate IMC acceleration as models grow.\n  We propose NL-DPE, a Non-Linear Dot Product Engine that overcomes these barriers. NL-DPE augments crosspoint arrays with RRAM-based Analog Content Addressable Memory (ACAM) to execute arbitrary non-linear functions and data-dependent matrix multiplications in the analog domain by transforming them into decision trees, fully eliminating ADCs. To address device noise, NL-DPE uses software-based Noise Aware Fine-tuning (NAF), requiring no in-device calibration. Experiments show that NL-DPE delivers 28X energy efficiency and 249X speedup over a GPU baseline, and 22X energy efficiency and 245X speedup over existing IMC accelerators, while maintaining high accuracy.", "AI": {"tldr": "NL-DPE is a Non-Linear Dot Product Engine that uses RRAM-based ACAM to execute arbitrary non-linear functions and data-dependent matrix multiplications in analog domain, eliminating ADCs and achieving significant speedup and energy efficiency over GPUs and existing IMC accelerators.", "motivation": "Overcome three major limitations of RRAM-based IMC accelerators: support only static dot-products, require large ADCs, and suffer from device nonideality errors, which hinder scalable and accurate acceleration of modern LLMs.", "method": "Augments crosspoint arrays with RRAM-based Analog Content Addressable Memory (ACAM) to transform non-linear functions and data-dependent multiplications into decision trees, and uses software-based Noise Aware Fine-tuning (NAF) to address device noise without in-device calibration.", "result": "Achieves 28X energy efficiency and 249X speedup over GPU baseline, and 22X energy efficiency and 245X speedup over existing IMC accelerators while maintaining high accuracy.", "conclusion": "NL-DPE successfully overcomes key barriers in RRAM-based IMC acceleration, enabling efficient execution of arbitrary non-linear functions and data-dependent operations essential for modern LLMs without requiring ADCs."}}
{"id": "2511.14400", "categories": ["cs.ET", "cs.PF"], "pdf": "https://arxiv.org/pdf/2511.14400", "abs": "https://arxiv.org/abs/2511.14400", "authors": ["I-Ting Lee", "Bao-Kai Wang", "Liang-Chi Chen", "Wen Sheng Lim", "Da-Wei Chang", "Yu-Ming Chang", "Chieng-Chung Ho"], "title": "PIM or CXL-PIM? Understanding Architectural Trade-offs Through Large-Scale Benchmarking", "comment": null, "summary": "Processing-in-memory (PIM) reduces data movement by executing near memory, but our large-scale characterization on real PIM hardware shows that end-to-end performance is often limited by disjoint host and device address spaces that force explicit staging transfers. In contrast, CXL-PIM provides a unified address space and cache-coherent access at the cost of higher access latency. These opposing interface models create workload-dependent tradeoffs that are not captured by small-scale studies. This work presents a side-by-side, large-scale comparison of PIM and CXL-PIM using measurements from real PIM hardware and trace-driven CXL modeling. We identify when unified-address access amortizes link latency enough to overcome transfer bottlenecks, and when tightly coupled PIM remains preferable. Our results reveal phase- and dataset-size regimes in which the relative ranking between the two architectures reverses, offering practical guidance for future near-memory system design.", "AI": {"tldr": "Large-scale comparison of PIM vs CXL-PIM architectures reveals workload-dependent performance tradeoffs, with unified address space sometimes overcoming transfer bottlenecks but tightly coupled PIM remaining preferable in other scenarios.", "motivation": "Current PIM systems suffer from disjoint host/device address spaces requiring explicit staging transfers, while CXL-PIM offers unified address space but higher latency. There's a need to understand when each approach performs better.", "method": "Conducted side-by-side large-scale comparison using real PIM hardware measurements and trace-driven CXL modeling to analyze performance tradeoffs.", "result": "Identified phase- and dataset-size regimes where relative performance ranking between PIM and CXL-PIM reverses, showing unified address access can overcome transfer bottlenecks in some cases.", "conclusion": "Provides practical guidance for future near-memory system design by revealing specific workload conditions where each architecture excels."}}
{"id": "2511.14202", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.14202", "abs": "https://arxiv.org/abs/2511.14202", "authors": ["Weiping Yang", "Shilin Zhou", "Hui Xu", "Yujiao Nie", "Qimin Zhou", "Zhiwei Li", "Changlin Chen"], "title": "A Bit Level Weight Reordering Strategy Based on Column Similarity to Explore Weight Sparsity in RRAM-based NN Accelerator", "comment": "accepted by ICPADS 2025 (International Conference on Parallel and Distributed Systems)", "summary": "Compute-in-Memory (CIM) and weight sparsity are two effective techniques to reduce data movement during Neural Network (NN) inference. However, they can hardly be employed in the same accelerator simultaneously because CIM requires structural compute patterns which are disrupted in sparse NNs. In this paper, we partially solve this issue by proposing a bit level weight reordering strategy which can realize compact mapping of sparse NN weight matrices onto Resistive Random Access Memory (RRAM) based NN Accelerators (RRAM-Acc). In specific, when weights are mapped to RRAM crossbars in a binary complement manner, we can observe that, which can also be mathematically proven, bit-level sparsity and similarity commonly exist in the crossbars. The bit reordering method treats bit sparsity as a special case of bit similarity, reserve only one column in a pair of columns that have identical bit values, and then map the compressed weight matrices into Operation Units (OU). The performance of our design is evaluated with typical NNs. Simulation results show a 61.24% average performance improvement and 1.51x-2.52x energy savings under different sparsity ratios, with only slight overhead compared to the state-of-the-art design.", "AI": {"tldr": "A bit-level weight reordering strategy enables simultaneous use of Compute-in-Memory (CIM) and weight sparsity in RRAM-based neural network accelerators by exploiting bit-level sparsity and similarity in weight matrices.", "motivation": "CIM and weight sparsity are both effective for reducing data movement in NN inference, but they cannot be used together because CIM requires structural compute patterns that are disrupted by sparse weights.", "method": "Proposes a bit-level weight reordering strategy that treats bit sparsity as a special case of bit similarity, reserves only one column in pairs of columns with identical bit values, and maps compressed weight matrices into Operation Units (OUs).", "result": "Simulation results show 61.24% average performance improvement and 1.51x-2.52x energy savings under different sparsity ratios, with only slight overhead compared to state-of-the-art designs.", "conclusion": "The proposed bit reordering method successfully enables the simultaneous use of CIM and weight sparsity in RRAM-based accelerators, achieving significant performance and energy efficiency improvements."}}
{"id": "2511.13928", "categories": ["cs.PF"], "pdf": "https://arxiv.org/pdf/2511.13928", "abs": "https://arxiv.org/abs/2511.13928", "authors": ["Maksymilian Graczyk", "Vincent Desbiolles", "Stefan Roiser", "Andrea Guerrieri"], "title": "Enabling Heterogeneous Performance Analysis for Scientific Workloads", "comment": "Accepted for publication as a short paper at IEEE HPEC'25 and got the Outstanding Short Paper Award there", "summary": "Heterogeneous computing integrates diverse processing elements, such as CPUs, GPUs, and FPGAs, within a single system, aiming to leverage the strengths of each architecture to optimize performance and energy consumption. In this context, efficient performance analysis plays a critical role in determining the most suitable platform for dispatching tasks, ensuring that workloads are allocated to the processing units where they can execute most effectively. Adaptyst is a novel ongoing effort at CERN, with the aim to develop an open-source, architecture-agnostic performance analysis for scientific workloads. This study explores the performance and implementation complexity of two built-in eBPF-based methods such as Uprobes and USDT, with the aim of outlining a roadmap for future integration into Adaptyst and advancing toward heterogeneous performance analysis capabilities.", "AI": {"tldr": "Adaptyst is an open-source performance analysis tool for scientific workloads on heterogeneous systems. This study evaluates eBPF-based methods (Uprobes and USDT) for future integration into Adaptyst to enable architecture-agnostic performance analysis across CPUs, GPUs, and FPGAs.", "motivation": "Heterogeneous computing systems combine different processing elements (CPUs, GPUs, FPGAs) to optimize performance and energy efficiency. Efficient performance analysis is crucial for determining the best platform for task dispatch and workload allocation.", "method": "The study explores two built-in eBPF-based methods: Uprobes and USDT (User Statically-Defined Tracing). These methods are evaluated for their performance and implementation complexity.", "result": "The research provides insights into the performance characteristics and implementation challenges of Uprobes and USDT methods, though specific quantitative results are not detailed in the abstract.", "conclusion": "The findings will help outline a roadmap for integrating eBPF-based performance analysis methods into Adaptyst, advancing toward comprehensive heterogeneous performance analysis capabilities for scientific workloads."}}
{"id": "2511.13778", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.13778", "abs": "https://arxiv.org/abs/2511.13778", "authors": ["Angelika Schwarz", "Anton Anders", "Cole Brower", "Harun Bayraktar", "John Gunnels", "Kate Clark", "RuQing G. Xu", "Samuel Rodriguez", "Sebastien Cayrols", "Pawe\u0142 Tabaszewski", "Victor Podlozhnyuk"], "title": "Guaranteed DGEMM Accuracy While Using Reduced Precision Tensor Cores Through Extensions of the Ozaki Scheme", "comment": null, "summary": "The rapid growth of artificial intelligence (AI) has made low-precision formats such as FP16, FP8, and, most recently, block-scaled FP4 the primary focus of modern GPUs, where Tensor Cores now deliver orders-of-magnitude higher throughput than traditional FP64 pipelines. This hardware shift has sparked a new line of algorithm research: using low-precision units to emulate double-precision accuracy through schemes such as Ozaki decompositions. We advance this direction with Automatic Dynamic Precision (ADP), a fully GPU-resident framework that makes emulated FP64 matrix multiplication both efficient and reliable. At its core is the Exponent Span Capacity (ESC), a hardware-agnostic estimator that conservatively determines the decomposition parameter (also known as slices) required to achieve FP64-level accuracy. Built on ESC, ADP integrates exception handling, run time heuristics, and seamless fallback to native FP64, ensuring correctness without host-device synchronization or user intervention. Additionally, we further improve Ozaki-style decompositions with an unsigned integer slicing scheme, which increases representational efficiency and reduces computational waste. Validated against recently proposed BLAS grading tests, ADP consistently preserves FP64 fidelity on challenging inputs while incurring less than 10% run time overhead. In a 55-bit mantissa setting, our approach achieves up to 2.3x and 13.2x speedups over native FP64 GEMM on NVIDIA Blackwell GB200 and the RTX Pro 6000 Blackwell Server Edition, respectively. Our results demonstrate that low-precision accelerators can serve as a practical, production-ready foundation for high-fidelity and high-performance scientific computing workloads.", "AI": {"tldr": "ADP is a GPU-resident framework that uses low-precision units to emulate FP64 accuracy through Ozaki decompositions, achieving up to 13.2x speedup over native FP64 while maintaining reliability.", "motivation": "The shift towards low-precision formats in modern GPUs has created an opportunity to use these efficient units for double-precision computations through emulation, enabling high-performance scientific computing on modern hardware.", "method": "ADP uses Exponent Span Capacity (ESC) to determine decomposition parameters, integrates exception handling and runtime heuristics, and employs an unsigned integer slicing scheme to improve efficiency in Ozaki-style decompositions.", "result": "ADP achieves up to 2.3x and 13.2x speedups over native FP64 GEMM on different NVIDIA hardware while preserving FP64 fidelity with less than 10% runtime overhead.", "conclusion": "Low-precision accelerators can serve as a practical foundation for high-fidelity scientific computing workloads, demonstrating that emulated FP64 through ADP provides both performance and reliability."}}
{"id": "2511.13779", "categories": ["cs.DC", "cs.AI", "cs.LG", "cs.NI", "eess.IV"], "pdf": "https://arxiv.org/pdf/2511.13779", "abs": "https://arxiv.org/abs/2511.13779", "authors": ["Mohammad Abdi", "Francesca Meneghello", "Francesco Restuccia"], "title": "Semantic Multiplexing", "comment": null, "summary": "Mobile devices increasingly require the parallel execution of several computing tasks offloaded at the wireless edge. Existing communication systems only support parallel transmissions at the bit level, which fundamentally limits the number of tasks that can be concurrently processed. To address this bottleneck, this paper introduces the new concept of Semantic Multiplexing. Our approach shifts stream multiplexing from bits to tasks by merging multiple task-related compressed representations into a single semantic representation. As such, Semantic Multiplexing can multiplex more tasks than the number of physical channels without adding antennas or widening bandwidth by extending the effective degrees of freedom at the semantic layer, without contradicting Shannon capacity rules. We have prototyped Semantic Multiplexing on an experimental testbed with Jetson Orin Nano and millimeter-wave software-defined radios and tested its performance on image classification and sentiment analysis while comparing to several existing baselines in semantic communications. Our experiments demonstrate that Semantic Multiplexing allows jointly processing multiple tasks at the semantic level while maintaining sufficient task accuracy. For example, image classification accuracy drops by less than 4% when increasing from 2 to 8 the number of tasks multiplexed over a 4$\\times$4 channel. Semantic Multiplexing reduces latency, energy consumption, and communication load respectively by up to 8$\\times$, 25$\\times$, and 54$\\times$ compared to the baselines while keeping comparable performance. We pledge to publicly share the complete software codebase and the collected datasets for reproducibility.", "AI": {"tldr": "Semantic Multiplexing enables parallel transmission of multiple computing tasks over wireless networks by merging compressed task representations into a single semantic stream, overcoming bit-level multiplexing limitations.", "motivation": "Existing communication systems only support parallel transmissions at the bit level, fundamentally limiting the number of tasks that can be concurrently processed at the wireless edge.", "method": "Shift stream multiplexing from bits to tasks by merging multiple task-related compressed representations into a single semantic representation, extending effective degrees of freedom at the semantic layer without adding physical resources.", "result": "Image classification accuracy drops by less than 4% when increasing from 2 to 8 tasks multiplexed over a 4\u00d74 channel. Reduces latency by 8\u00d7, energy consumption by 25\u00d7, and communication load by 54\u00d7 compared to baselines while maintaining comparable performance.", "conclusion": "Semantic Multiplexing enables joint processing of multiple tasks at the semantic level while maintaining sufficient task accuracy, significantly improving efficiency for edge computing applications."}}
{"id": "2511.13804", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.13804", "abs": "https://arxiv.org/abs/2511.13804", "authors": ["Temitayo Adefemi"], "title": "Do MPI Derived Datatypes Actually Help? A Single-Node Cross-Implementation Study on Shared-Memory Communication", "comment": "9 pages, 6 figures", "summary": "MPI's derived datatypes (DDTs) promise easier, copy-free communication of non-contiguous data, yet their practical performance remains debated and is often reported only for a single MPI stack. We present a cross-implementation assessment using three 2D applications: a Jacobi CFD solver, Conway's Game of Life, and a lattice-based image reconstruction. Each application is written in two ways: (i) a BASIC version with manual packing and unpacking of non-contiguous regions and (ii) a DDT version using MPI_Type_vector and MPI_Type_create_subarray with correct true extent via MPI_Type_create_resized. For API parity, we benchmark identical communication semantics: non-blocking point-to-point (Irecv/Isend + Waitall), neighborhood collectives (MPI_Neighbor_alltoallw), and MPI-4 persistent operations (*_init). We run strong and weak scaling on 1-4 ranks, validate bitwise-identical halos, and evaluate four widely used MPI implementations: MPICH, Open MPI, Intel MPI, and MVAPICH2 on a single ARCHER2 node. Results are mixed. DDTs can be fastest, for example for the image reconstruction code on Intel MPI and MPICH, but can also be among the slowest on other stacks, such as Open MPI and MVAPICH2 for the same code. For the CFD solver, BASIC variants generally outperform DDTs across semantics, whereas for Game of Life the ranking flips depending on the MPI library. We also observe stack-specific anomalies, for example MPICH slowdowns with DDT neighborhood and persistent modes. Overall, no strategy dominates across programs, semantics, and MPI stacks; performance portability for DDTs is not guaranteed. We therefore recommend profiling both DDT-based and manual-packing designs under the intended MPI implementation and communication mode. Our study is limited to a single node and does not analyze memory overhead; multi-node and GPU-aware paths are left for future work.", "AI": {"tldr": "Cross-implementation performance assessment of MPI derived datatypes (DDTs) vs manual packing across 3 applications and 4 MPI stacks shows mixed results - DDTs can be fastest or slowest depending on the specific MPI implementation and application.", "motivation": "To provide a comprehensive cross-implementation assessment of MPI derived datatypes' practical performance, addressing the ongoing debate about their efficiency compared to manual packing methods.", "method": "Evaluated three 2D applications (Jacobi CFD solver, Conway's Game of Life, lattice-based image reconstruction) with both manual packing (BASIC) and DDT versions using MPI_Type_vector and MPI_Type_create_subarray. Tested across four MPI implementations (MPICH, Open MPI, Intel MPI, MVAPICH2) on a single ARCHER2 node with strong/weak scaling on 1-4 ranks.", "result": "Mixed performance results: DDTs can be fastest (e.g., image reconstruction on Intel MPI and MPICH) or slowest (same code on Open MPI and MVAPICH2). CFD solver BASIC variants generally outperform DDTs, while Game of Life performance ranking flips by MPI library. Stack-specific anomalies observed (e.g., MPICH slowdowns with DDT neighborhood/persistent modes).", "conclusion": "No single strategy dominates across programs, semantics, and MPI stacks; performance portability for DDTs is not guaranteed. Recommendation: profile both DDT-based and manual-packing designs under intended MPI implementation and communication mode."}}
{"id": "2511.13940", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.13940", "abs": "https://arxiv.org/abs/2511.13940", "authors": ["Stuart H. Sul", "Simran Arora", "Benjamin F. Spector", "Christopher R\u00e9"], "title": "ParallelKittens: Systematic and Practical Simplification of Multi-GPU AI Kernels", "comment": null, "summary": "Inter-GPU communication has become a major bottleneck for modern AI workloads as models scale and improvements in hardware compute throughput outpace improvements in interconnect bandwidth. Existing systems mitigate this through compute-communication overlap but often fail to meet theoretical peak performance across heterogeneous workloads and new accelerators. Instead of operator-specific techniques, we ask whether a small set of simple, reusable principles can systematically guide the design of optimal multi-GPU kernels. We present ParallelKittens (PK), a minimal CUDA framework that drastically simplifies the development of overlapped multi-GPU kernels. PK extends the ThunderKittens framework and embodies the principles of multi-GPU kernel design through eight core primitives and a unified programming template, derived from a comprehensive analysis of the factors that govern multi-GPU performance$\\unicode{x2014}$data-transfer mechanisms, resource scheduling, and design overheads. We validate PK on both Hopper and Blackwell architectures. With fewer than 50 lines of device code, PK achieves up to $2.33 \\times$ speedup for data- and tensor-parallel workloads, $4.08 \\times$ for sequence-parallel workloads, and $1.22 \\times$ for expert-parallel workloads.", "AI": {"tldr": "ParallelKittens (PK) is a minimal CUDA framework that simplifies overlapped multi-GPU kernel development using eight core primitives and a unified template, achieving significant speedups across various parallel workloads on Hopper and Blackwell architectures.", "motivation": "Inter-GPU communication has become a major bottleneck for AI workloads as model scaling and hardware compute improvements outpace interconnect bandwidth, with existing systems often failing to achieve theoretical peak performance across heterogeneous workloads and new accelerators.", "method": "PK extends ThunderKittens framework with eight core primitives and a unified programming template derived from analysis of multi-GPU performance factors including data-transfer mechanisms, resource scheduling, and design overheads.", "result": "PK achieves up to 2.33\u00d7 speedup for data- and tensor-parallel workloads, 4.08\u00d7 for sequence-parallel workloads, and 1.22\u00d7 for expert-parallel workloads using fewer than 50 lines of device code on Hopper and Blackwell architectures.", "conclusion": "A small set of simple, reusable principles can systematically guide the design of optimal multi-GPU kernels, enabling significant performance improvements across diverse parallel workloads with minimal code complexity."}}
{"id": "2511.14116", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.14116", "abs": "https://arxiv.org/abs/2511.14116", "authors": ["Ziyi Xu", "Zhiqiang Xie", "Swapnil Gandhi", "Christos Kozyrakis"], "title": "FailSafe: High-performance Resilient Serving", "comment": null, "summary": "Tensor parallelism (TP) enables large language models (LLMs) to scale inference efficiently across multiple GPUs, but its tight coupling makes systems fragile: a single GPU failure can halt execution, trigger costly KVCache recomputation, and introduce long-term compute and memory imbalance. We present FailSafe, a fault-tolerant TP serving system that sustains high performance under irregular GPU availability. FailSafe introduces three techniques to balance computation and memory across GPUs: (1) Cyclic KVCache Placement for uniform memory utilization, (2) Hybrid Attention combining tensor- and data-parallel attention to eliminate stragglers, and (3) Fine-Grained Load-Aware Routing to dynamically balance requests. It further employs proactive KVCache backup and on-demand weight recovery to avoid expensive recomputation and redundant data transfers. We implement these techniques in a lightweight serving engine compatible with existing LLM infrastructures. Evaluated on an 8xH100 DGX system with real-world fault traces and representative workloads, FailSafe achieves up to 2x higher throughput and two orders of magnitude lower recovery latency compared to standard fault handling approaches. Even with up to three GPU failures, FailSafe sustains high throughput and balanced utilization, demonstrating robust and efficient LLM serving under dynamic and unreliable hardware conditions.", "AI": {"tldr": "FailSafe is a fault-tolerant tensor parallelism system for LLM serving that maintains high performance during GPU failures through cyclic KVCache placement, hybrid attention, and dynamic load balancing, achieving 2x higher throughput and significantly faster recovery.", "motivation": "Standard tensor parallelism systems are fragile - a single GPU failure halts execution, triggers expensive KVCache recomputation, and causes long-term compute/memory imbalance, making LLM serving unreliable in dynamic hardware environments.", "method": "Three key techniques: (1) Cyclic KVCache Placement for uniform memory utilization, (2) Hybrid Attention combining tensor- and data-parallel attention to eliminate stragglers, (3) Fine-Grained Load-Aware Routing for dynamic request balancing. Plus proactive KVCache backup and on-demand weight recovery.", "result": "On 8xH100 DGX system with real-world fault traces: up to 2x higher throughput, two orders of magnitude lower recovery latency compared to standard approaches. Sustains high throughput and balanced utilization even with up to three GPU failures.", "conclusion": "FailSafe demonstrates robust and efficient LLM serving under dynamic and unreliable hardware conditions, providing fault tolerance without sacrificing performance."}}
{"id": "2511.14124", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.14124", "abs": "https://arxiv.org/abs/2511.14124", "authors": ["Sabiha Afroz", "Redwan Ibne Seraj Khan", "Hadeel Albahar", "Jingoo Han", "Ali R. Butt"], "title": "10Cache: Heterogeneous Resource-Aware Tensor Caching and Migration for LLM Training", "comment": "This paper accepted for presentation to the 16th ACM Symposium on Cloud Computing (SOCC'25)", "summary": "Training large language models (LLMs) in the cloud faces growing memory bottlenecks due to the limited capacity and high cost of GPUs. While GPU memory offloading to CPU and NVMe has made large-scale training more feasible, existing approaches suffer from high tensor migration latency and suboptimal device memory utilization, ultimately increasing training time and cloud costs. To address these challenges, we present 10Cache, a resource-aware tensor caching and migration system that accelerates LLM training by intelligently coordinating memory usage across GPU, CPU, and NVMe tiers. 10Cache profiles tensor execution order to construct prefetch policies, allocates memory buffers in pinned memory based on tensor size distributions, and reuses memory buffers to minimize allocation overhead.\n  Designed for cloud-scale deployments, 10Cache improves memory efficiency and reduces reliance on high-end GPUs. Across diverse LLM workloads, it achieves up to 2x speedup in training time, improves GPU cache hit rate by up to 86.6x, and increases CPU/GPU memory utilization by up to 2.15x and 1.33x, respectively, compared to state-of-the-art offloading methods. These results demonstrate that 10Cache is a practical and scalable solution for optimizing LLM training throughput and resource efficiency in cloud environments.", "AI": {"tldr": "10Cache is a resource-aware tensor caching and migration system that accelerates LLM training by intelligently coordinating memory usage across GPU, CPU, and NVMe tiers, achieving up to 2x speedup in training time.", "motivation": "Training large language models in the cloud faces growing memory bottlenecks due to limited GPU capacity and high costs, with existing offloading approaches suffering from high tensor migration latency and suboptimal device memory utilization.", "method": "10Cache profiles tensor execution order to construct prefetch policies, allocates memory buffers in pinned memory based on tensor size distributions, and reuses memory buffers to minimize allocation overhead across GPU, CPU, and NVMe tiers.", "result": "Across diverse LLM workloads, 10Cache achieves up to 2x speedup in training time, improves GPU cache hit rate by up to 86.6x, and increases CPU/GPU memory utilization by up to 2.15x and 1.33x respectively compared to state-of-the-art offloading methods.", "conclusion": "10Cache is a practical and scalable solution for optimizing LLM training throughput and resource efficiency in cloud environments, reducing reliance on high-end GPUs while improving memory efficiency."}}
{"id": "2511.14450", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.14450", "abs": "https://arxiv.org/abs/2511.14450", "authors": ["Mulei Ma", "Minrui Xu", "Zihan Chen", "Yang Yang", "Tony Q. S. Quek"], "title": "Hyperion: Hierarchical Scheduling for Parallel LLM Acceleration in Multi-tier Networks", "comment": null, "summary": "Large Language Models (LLMs) are increasingly executed across edge, fog, and cloud tiers where limited GPU memory, heterogeneous compute, and variable inter-tier bandwidth jointly constrain deployment and motivate model partitioning and request scheduling. In this setting, achieving low end-to-end latency is governed not only by where a model is deployed (inter-tier model partitioning) but also by how incoming requests are scheduled (intra-tier task scheduling) across heterogeneous nodes. These two problems are tightly coupled, as a suboptimal scheduler can negate the benefits of a good partition, and vice versa. In this paper, we propose Hyperion, a hierarchical two-stage framework that jointly optimizes partitioning and scheduling to minimize end-to-end latency for pipelined LLM inference in multi-tier networks, balancing compute and memory across tiers while introducing negligible runtime overhead and requiring no model retraining. Motivated by the observation that partition choices evolve on slower timescales than request arrivals, Stage 1 performs offline, inter-tier partitioning via a Binary Search with Dynamic Programming (BSDP) procedure to produce balanced stage times under tier capacity and memory constraints; to adapt to time-varying load, Stage 2 performs online, intra-tier scheduling with a lightweight Adaptive Real-time Task Scheduling (ARTS) algorithm that maps each request to the best available node using real-time estimates of queue length and effective capacity. Experimental results on multi-tier inference tasks demonstrate that Hyperion significantly reduces end-to-end latency by up to 52.1\\% and 31.2\\%, with the Phi-3-medium model, compared to the GPipe and HEFT baselines, respectively. Furthermore, Hyperion shows superior scalability in long-sequence generation, maintaining a 44.5\\% lower latency than GPipe and achieving higher GPU utilization.", "AI": {"tldr": "Hyperion is a hierarchical two-stage framework that jointly optimizes model partitioning and request scheduling to minimize end-to-end latency for LLM inference in multi-tier networks, achieving up to 52.1% latency reduction compared to baselines.", "motivation": "LLMs are deployed across edge, fog, and cloud tiers with constraints on GPU memory, heterogeneous compute, and variable bandwidth, requiring coordinated optimization of model partitioning and request scheduling to achieve low latency.", "method": "Two-stage approach: Stage 1 performs offline inter-tier partitioning using Binary Search with Dynamic Programming for balanced stage times; Stage 2 performs online intra-tier scheduling with Adaptive Real-time Task Scheduling algorithm using real-time queue and capacity estimates.", "result": "Hyperion reduces end-to-end latency by up to 52.1% and 31.2% compared to GPipe and HEFT baselines respectively, with superior scalability in long-sequence generation and 44.5% lower latency than GPipe while achieving higher GPU utilization.", "conclusion": "Hyperion effectively minimizes LLM inference latency in multi-tier networks through joint optimization of partitioning and scheduling, introducing negligible runtime overhead without requiring model retraining."}}
{"id": "2511.14456", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.14456", "abs": "https://arxiv.org/abs/2511.14456", "authors": ["Fabian Stricker", "David Bermbach", "Christian Zirpins"], "title": "Analyzing the Impact of Participant Failures in Cross-Silo Federated Learning", "comment": "Accepted for publication in 3rd IEEE International Conference on Federated Learning Applications and Technologies (FLTA2025)", "summary": "Federated learning (FL) is a new paradigm for training machine learning (ML) models without sharing data. While applying FL in cross-silo scenarios, where organizations collaborate, it is necessary that the FL system is reliable; however, participants can fail due to various reasons (e.g., communication issues or misconfigurations). In order to provide a reliable system, it is necessary to analyze the impact of participant failures. While this problem received attention in cross-device FL where mobile devices with limited resources participate, there is comparatively little research in cross-silo FL.\n  Therefore, we conduct an extensive study for analyzing the impact of participant failures on the model quality in the context of inter-organizational cross-silo FL with few participants. In our study, we focus on analyzing generally influential factors such as the impact of the timing and the data as well as the impact on the evaluation, which is important for deciding, if the model should be deployed. We show that under high skews the evaluation is optimistic and hides the real impact. Furthermore, we demonstrate that the timing impacts the quality of the trained model. Our results offer insights for researchers and software architects aiming to build robust FL systems.", "AI": {"tldr": "This paper analyzes the impact of participant failures on model quality in cross-silo federated learning, focusing on timing, data distribution, and evaluation reliability under high data skew conditions.", "motivation": "While federated learning enables collaborative model training without data sharing, participant failures can compromise system reliability. There's limited research on failure impacts in cross-silo FL with few organizational participants compared to cross-device FL.", "method": "The authors conducted an extensive study analyzing influential factors including timing of failures, data distribution effects, and evaluation reliability, specifically examining cross-silo FL scenarios with few participants.", "result": "The study reveals that under high data skews, evaluation metrics become optimistic and mask the real impact of failures. The timing of participant failures significantly affects the quality of the trained model.", "conclusion": "The findings provide valuable insights for researchers and software architects to build more robust federated learning systems that can better handle participant failures in cross-silo environments."}}
{"id": "2511.14608", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.14608", "abs": "https://arxiv.org/abs/2511.14608", "authors": ["Dave Dice", "Alex Kogan"], "title": "Hapax Locks : Value-Based Mutual Exclusion", "comment": null, "summary": "We present Hapax Locks, a novel locking algorithm that is simple, enjoys constant-time arrival and unlock paths, provides FIFO admission order, and which is also space efficient and generates relatively little coherence traffic under contention in the common case. Hapax Locks offer performance (both latency and scalability) that is comparable with the best state of the art locks, while at the same time Hapax Locks impose fewer constraints and dependencies on the ambient runtime environment, making them particularly easy to integrate or retrofit into existing systems or under existing application programming interfaces Of particular note, no pointers shift or escape ownership between threads in our algorithm.", "AI": {"tldr": "Hapax Locks is a novel locking algorithm that provides constant-time operations, FIFO admission order, space efficiency, and low coherence traffic while being easy to integrate into existing systems.", "motivation": "To develop a locking algorithm that combines high performance with minimal dependencies on runtime environments, making it easy to retrofit into existing systems without complex pointer management between threads.", "method": "The Hapax Locks algorithm achieves constant-time arrival and unlock paths through a design that avoids pointer shifting or ownership transfer between threads, maintaining FIFO admission order while minimizing coherence traffic.", "result": "Hapax Locks demonstrate performance comparable to state-of-the-art locks in both latency and scalability, while generating relatively little coherence traffic under contention and requiring fewer environmental constraints.", "conclusion": "Hapax Locks represent an effective locking solution that balances high performance with ease of integration, making them particularly suitable for retrofitting into existing systems without complex runtime dependencies."}}
{"id": "2511.14617", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.14617", "abs": "https://arxiv.org/abs/2511.14617", "authors": ["Ruoyu Qin", "Weiran He", "Weixiao Huang", "Yangkun Zhang", "Yikai Zhao", "Bo Pang", "Xinran Xu", "Yingdi Shan", "Yongwei Wu", "Mingxing Zhang"], "title": "Seer: Online Context Learning for Fast Synchronous LLM Reinforcement Learning", "comment": "16 pages, 12 figures, 6 tables", "summary": "Reinforcement Learning (RL) has become critical for advancing modern Large Language Models (LLMs), yet existing synchronous RL systems face severe performance bottlenecks. The rollout phase, which dominates end-to-end iteration time, suffers from substantial long-tail latency and poor resource utilization due to inherent workload imbalance. We present Seer, a novel online context learning system that addresses these challenges by exploiting previously overlooked similarities in output lengths and generation patterns among requests sharing the same prompt. Seer introduces three key techniques: divided rollout for dynamic load balancing, context-aware scheduling, and adaptive grouped speculative decoding. Together, these mechanisms substantially reduce long-tail latency and improve resource efficiency during rollout. Evaluations on production-grade RL workloads demonstrate that Seer improves end-to-end rollout throughput by 74% to 97% and reduces long-tail latency by 75% to 93% compared to state-of-the-art synchronous RL systems, significantly accelerating RL training iterations.", "AI": {"tldr": "Seer is a novel online context learning system that addresses performance bottlenecks in synchronous RL systems for LLMs by exploiting similarities in output patterns among requests with the same prompt, achieving significant improvements in throughput and latency reduction.", "motivation": "Existing synchronous RL systems for LLMs face severe performance bottlenecks, particularly in the rollout phase which dominates iteration time. This phase suffers from long-tail latency and poor resource utilization due to workload imbalance.", "method": "Seer introduces three key techniques: divided rollout for dynamic load balancing, context-aware scheduling, and adaptive grouped speculative decoding. These exploit similarities in output lengths and generation patterns among requests sharing the same prompt.", "result": "Evaluations show Seer improves end-to-end rollout throughput by 74% to 97% and reduces long-tail latency by 75% to 93% compared to state-of-the-art synchronous RL systems.", "conclusion": "Seer significantly accelerates RL training iterations by substantially reducing long-tail latency and improving resource efficiency during the rollout phase of LLM training."}}
