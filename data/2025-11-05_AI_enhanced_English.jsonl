{"id": "2511.01860", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.01860", "abs": "https://arxiv.org/abs/2511.01860", "authors": ["Leszek Sliwko"], "title": "A Taxonomy of Schedulers -- Operating Systems, Clusters and Big Data Frameworks", "comment": "This is the accepted author's version of the paper. The final\n  published version is available in Global Journal of Computer Science and\n  Technology, 2019", "summary": "This review analyzes deployed and actively used workload schedulers'\nsolutions and presents a taxonomy in which those systems are divided into\nseveral hierarchical groups based on their architecture and design. While other\ntaxonomies do exist, this review has focused on the key design factors that\naffect the throughput and scalability of a given solution, as well as the\nincremental improvements which bettered such an architecture. This review gives\nspecial attention to Google's Borg, which is one of the most advanced and\npublished systems of this kind.", "AI": {"tldr": "This review presents a taxonomy of workload schedulers based on architecture and design, focusing on key factors affecting throughput and scalability, with special attention to Google's Borg as an advanced example.", "motivation": "To analyze deployed workload schedulers and create a hierarchical taxonomy based on their architecture and design, focusing on factors that impact throughput and scalability.", "method": "The review analyzes actively used workload schedulers, categorizes them into hierarchical groups based on architecture and design, and examines incremental improvements that enhanced system architecture.", "result": "A taxonomy of workload schedulers is presented, with Google's Borg identified as one of the most advanced published systems in this category.", "conclusion": "The review provides a structured classification of workload schedulers that highlights key design factors affecting performance and scalability, with Borg serving as a benchmark for advanced systems."}}
{"id": "2511.01861", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.01861", "abs": "https://arxiv.org/abs/2511.01861", "authors": ["Johan Messchendorp", "Mohammad Al-Turany", "Volker Friese", "Thorsten Kollegger", "Bastian Loeher", "Jochen Markert", "Andrew Mistry", "Thomas Neff", "Adrian Oeftiger", "Michael Papenbrock", "Stephane Pietri", "Shahab Sanjari", "Tobias Stockmanns"], "title": "Conceptual Design Report for FAIR Computing", "comment": "88 pages, Conceptual Design Report for FAIR Computing", "summary": "This Conceptual Design Report (CDR) presents the plans of the computing\ninfrastructure for research at FAIR, Darmstadt, Germany. It presents the\ncomputing requirements of the various research groups, the policies for the\ncomputing and storage infrastructure, the foreseen FAIR computing model\nincluding the open data, software and services policies and architecture for\nthe periods starting in 2028 with the \"first science (plus)\" phase to the\nmodularized start version of FAIR. The overall ambition is to create a\nfederated and centrally-orchestrated infrastructure serving the large diversity\nof the research lines present with sufficient scalability and flexibility to\ncope with future data challenges that will be present at FAIR.", "AI": {"tldr": "This CDR outlines FAIR's computing infrastructure plans from 2028 onward, focusing on federated, scalable systems to support diverse research needs with open data policies.", "motivation": "To establish a comprehensive computing infrastructure that meets the varied requirements of FAIR's research groups while ensuring scalability and flexibility for future data challenges.", "method": "Proposes a federated and centrally-orchestrated computing model with open data, software, and services policies, designed to serve multiple research lines from initial science phase to full modular implementation.", "result": "A detailed conceptual design for computing infrastructure that addresses current research requirements while being adaptable to future data demands at FAIR.", "conclusion": "The plan aims to create a robust, scalable computing ecosystem that can effectively support FAIR's diverse research programs through a federated architecture with central coordination."}}
{"id": "2511.01862", "categories": ["cs.DC", "cs.CY"], "pdf": "https://arxiv.org/pdf/2511.01862", "abs": "https://arxiv.org/abs/2511.01862", "authors": ["Vanessa Sochat", "Daniel Milroy"], "title": "Possible Futures for Cloud Cost Models", "comment": "10 pages", "summary": "Cloud is now the leading software and computing hardware innovator, and is\nchanging the landscape of compute to one that is optimized for artificial\nintelligence and machine learning (AI/ML). Computing innovation was initially\ndriven to meet the needs of scientific computing. As industry and consumer\nusage of computing proliferated, there was a shift to satisfy a multipolar\ncustomer base. Demand for AI/ML now dominates modern computing and innovation\nhas centralized on cloud. As a result, cost and resource models designed to\nserve AI/ML use cases are not currently well suited for science. If resource\ncontention resulting from a unipole consumer makes access to contended\nresources harder for scientific users, a likely future is running scientific\nworkloads where they were not intended. In this article, we discuss the past,\ncurrent, and possible futures of cloud cost models for the continued support of\ndiscovery and science.", "AI": {"tldr": "Cloud computing innovation has shifted from scientific computing to AI/ML dominance, creating cost models that don't suit scientific needs, potentially forcing science to run on unintended platforms.", "motivation": "To examine how cloud computing's focus on AI/ML has created resource models that are poorly suited for scientific computing, potentially limiting scientific discovery.", "method": "Analysis of past, current, and potential future cloud cost models through discussion of computing evolution from scientific to AI/ML-driven innovation.", "result": "Current cloud cost models designed for AI/ML use cases create resource contention issues for scientific users, potentially forcing scientific workloads to run on unintended platforms.", "conclusion": "There is a need to develop cloud cost models that better support scientific discovery alongside AI/ML workloads to ensure continued scientific progress."}}
{"id": "2511.01863", "categories": ["cs.DC", "cs.DM"], "pdf": "https://arxiv.org/pdf/2511.01863", "abs": "https://arxiv.org/abs/2511.01863", "authors": ["Robert Fabian Lindermann", "Paul-Niklas Ken Kandora", "Simon Caspar Zeller", "Adrian Asmund Fessler", "Steffen Rebennack"], "title": "SPHERE: Spherical partitioning for large-scale routing optimization", "comment": null, "summary": "We study shortest-path routing in large weighted, undirected graphs, where\nexpanding search frontiers raise time and memory costs for exact solvers. We\npropose \\emph{SPHERE}, a source-target-aware heuristic that identifies an\n$s$-$t$ overlap: vertices that are close to both $s$ and $t$ in hop count.\nSelecting an anchor $a$ in this overlap partitions the task into two\nsubproblems with unchanged problem-topology, $s\\to a$ and $a\\to t$; if either\nremains large, the procedure recurses on its induced subgraph. Because the cut\nlies inside the overlap, concatenating the resulting subpaths yields a valid\n$s\\to t$ route without boundary repair. SPHERE is independent of the downstream\nsolver (e.g., Dijkstra) and exposes parallelism across subproblems. On large\nnetworks, it achieves faster runtimes and smaller optimality gaps than\nLouvain-based routing and a METIS-based pipeline, even on graphs with more than\na million nodes and edges, while also outperforming Dijkstra in runtime.", "AI": {"tldr": "SPHERE is a heuristic routing algorithm that identifies vertices close to both source and target, then recursively partitions the path-finding problem into smaller subproblems without requiring boundary repair, achieving faster runtimes than existing methods on large graphs.", "motivation": "Traditional shortest-path routing algorithms face time and memory challenges when expanding search frontiers in large weighted undirected graphs, necessitating more efficient approaches.", "method": "SPHERE identifies an s-t overlap (vertices close to both source and target in hop count), selects an anchor in this overlap to partition the problem into subproblems s\u2192a and a\u2192t, and recursively applies the same procedure on large subproblems using their induced subgraphs.", "result": "SPHERE achieves faster runtimes and smaller optimality gaps than Louvain-based routing and METIS-based pipeline on large networks with over a million nodes and edges, while also outperforming Dijkstra in runtime.", "conclusion": "SPHERE provides an effective heuristic for shortest-path routing in large graphs by leveraging source-target awareness and recursive partitioning, offering improved performance over existing methods without requiring boundary repair."}}
{"id": "2511.02034", "categories": ["cs.DC", "cs.ET", "cs.NI"], "pdf": "https://arxiv.org/pdf/2511.02034", "abs": "https://arxiv.org/abs/2511.02034", "authors": ["Shashank Motepalli", "Naman Garg", "Gengrui Zhang", "Hans-Arno Jacobsen"], "title": "GPoS: Geospatially-aware Proof of Stake", "comment": "Published in ACM TWEB", "summary": "Geospatial decentralization is essential for blockchains, ensuring regulatory\nresilience, robustness, and fairness. We empirically analyze five major Proof\nof Stake (PoS) blockchains: Aptos, Avalanche, Ethereum, Solana, and Sui,\nrevealing that a few geographic regions dominate consensus voting power,\nresulting in limited geospatial decentralization. To address this, we propose\nGeospatially aware Proof of Stake (GPoS), which integrates geospatial diversity\nwith stake-based voting power. Experimental evaluation demonstrates an average\n45% improvement in geospatial decentralization, as measured by the Gini\ncoefficient of Eigenvector centrality, while incurring minimal performance\noverhead in BFT protocols, including HotStuff and CometBFT. These results\ndemonstrate that GPoS can improve geospatial decentralization {while, in our\nexperiments, incurring minimal overhead} to consensus performance.", "AI": {"tldr": "The paper analyzes geospatial decentralization in major PoS blockchains and proposes GPoS to improve it with minimal performance impact.", "motivation": "Current Proof of Stake blockchains show limited geospatial decentralization, with consensus voting power concentrated in few geographic regions, which threatens regulatory resilience, robustness, and fairness.", "method": "Proposed Geospatially aware Proof of Stake (GPoS) that integrates geospatial diversity with stake-based voting power, evaluated experimentally on BFT protocols like HotStuff and CometBFT.", "result": "Experimental evaluation shows 45% average improvement in geospatial decentralization (measured by Gini coefficient of Eigenvector centrality) with minimal performance overhead in consensus protocols.", "conclusion": "GPoS effectively improves geospatial decentralization in PoS blockchains while maintaining minimal impact on consensus performance."}}
{"id": "2511.02230", "categories": ["cs.OS", "cs.AI", "cs.NI"], "pdf": "https://arxiv.org/pdf/2511.02230", "abs": "https://arxiv.org/abs/2511.02230", "authors": ["Hanchen Li", "Qiuyang Mang", "Runyuan He", "Qizheng Zhang", "Huanzhi Mao", "Xiaokun Chen", "Alvin Cheung", "Joseph Gonzalez", "Ion Stoica"], "title": "Continuum: Efficient and Robust Multi-Turn LLM Agent Scheduling with KV Cache Time-to-Live", "comment": null, "summary": "Agentic LLM applications interleave LLM generation requests with tool calls.\nThese tool calls break the continuity of the workflow by creating pauses\nbetween LLM requests, bringing many challenges for the serving system,\nespecially under multi-turn scenarios. Each pause potentially causes KV cache\neviction and extra waiting time before entering the continuous batch for the\nfollowing LLM request. Since these pauses happen for each call, this problem\nbecomes increasingly severe as turn number grow for agentic programs. Previous\nworks either fail to incorporate information from the tool call, evicting KV\ncache that leads to repetitive prefill or loading, or ignore the continuity of\na multi-turn program, creating waiting time between turns that increases\nper-request latency.\n  We present Continuum, a serving system to optimize job completion time for\nmulti-turn agent workloads by combining tool-aware KV cache timeout with\nprogram-level scheduling. By predicting tool call durations in agentic\nworkflows, Continuum selectively pins the KV cache in GPU memory with a\ntime-to-live value based on total turn number. When combined with program-level\nfirst-come-first-serve, Continuum prevents scheduling bubbles, preserves\nmulti-turn continuity, and optimizes for throughput for complex agentic\nworkflows. By modeling the variability of tool call and agent program\ncontinuity, Continuum outperforms state-of-the-art baselines. Our evaluation on\nreal-world agentic workloads (SWE-Bench and BFCL) with Llama-3.1 8B/70B models\nshows that Continuum significantly improves the average job completion times,\nand remains performant across different hardware setups and DRAM offloading\nschemes. Preview code is available at:\nhttps://github.com/Hanchenli/vllm-continuum", "AI": {"tldr": "Continuum is a serving system that optimizes job completion time for multi-turn agent workloads by combining tool-aware KV cache timeout with program-level scheduling to address pauses caused by tool calls.", "motivation": "Agentic LLM applications face challenges with workflow continuity due to pauses from tool calls, causing KV cache eviction and increased waiting times in multi-turn scenarios, which existing solutions fail to address effectively.", "method": "Continuum predicts tool call durations and selectively pins KV cache in GPU memory with time-to-live values based on turn number, combined with program-level first-come-first-serve scheduling to prevent scheduling bubbles.", "result": "Evaluation on real-world agentic workloads (SWE-Bench and BFCL) with Llama-3.1 8B/70B models shows Continuum significantly improves average job completion times and performs well across different hardware setups and DRAM offloading schemes.", "conclusion": "Continuum effectively addresses the continuity challenges in multi-turn agent workloads by modeling tool call variability and program continuity, outperforming state-of-the-art baselines."}}
{"id": "2511.02132", "categories": ["cs.AR", "cs.DC", "cs.LG", "cs.PF"], "pdf": "https://arxiv.org/pdf/2511.02132", "abs": "https://arxiv.org/abs/2511.02132", "authors": ["Mansi Choudhary", "Karthik Sangaiah", "Sonali Singh", "Muhammad Osama", "Lisa Wu Wills", "Ganesh Dasika"], "title": "Optimizing Attention on GPUs by Exploiting GPU Architectural NUMA Effects", "comment": "11 pages, 14 figures", "summary": "The rise of disaggregated AI GPUs has exposed a critical bottleneck in\nlarge-scale attention workloads: non-uniform memory access (NUMA). As\nmulti-chiplet designs become the norm for scaling compute capabilities, memory\nlatency and bandwidth vary sharply across compute regions, undermining the\nperformance of traditional GPU kernel scheduling strategies that assume uniform\nmemory access. We identify how these NUMA effects distort locality in\nmulti-head attention (MHA) and present Swizzled Head-first Mapping, a\nspatially-aware scheduling strategy that aligns attention heads with GPU NUMA\ndomains to exploit intra-chiplet cache reuse. On AMD's MI300X architecture, our\nmethod achieves up to 50% higher performance over state-of-the-art attention\nalgorithms using conventional scheduling techniques and sustains consistently\nhigh L2 cache hit rates of 80-97%. These results demonstrate that NUMA-aware\nscheduling is now fundamental to achieving full efficiency on next-generation\ndisaggregated GPUs, offering a path forward for scalable AI training and\ninference.", "AI": {"tldr": "Swizzled Head-first Mapping addresses NUMA bottlenecks in disaggregated AI GPUs by spatially aligning attention heads with GPU NUMA domains, achieving 50% higher performance and 80-97% L2 cache hit rates on AMD MI300X.", "motivation": "Disaggregated AI GPUs with multi-chiplet designs suffer from non-uniform memory access (NUMA) effects that undermine traditional GPU kernel scheduling strategies, creating critical bottlenecks in large-scale attention workloads.", "method": "Swizzled Head-first Mapping - a spatially-aware scheduling strategy that aligns attention heads with GPU NUMA domains to exploit intra-chiplet cache reuse.", "result": "On AMD's MI300X architecture, achieves up to 50% higher performance over state-of-the-art attention algorithms and sustains consistently high L2 cache hit rates of 80-97%.", "conclusion": "NUMA-aware scheduling is fundamental to achieving full efficiency on next-generation disaggregated GPUs, offering a path forward for scalable AI training and inference."}}
{"id": "2511.01866", "categories": ["cs.DC", "cs.AI", "cs.AR"], "pdf": "https://arxiv.org/pdf/2511.01866", "abs": "https://arxiv.org/abs/2511.01866", "authors": ["Benjamin Kubwimana", "Qijing Huang"], "title": "EdgeReasoning: Characterizing Reasoning LLM Deployment on Edge GPUs", "comment": "Published in the Proceedings of the 2025 IEEE International Symposium\n  on Workload Characterization (IISWC 2025)", "summary": "Edge intelligence paradigm is increasingly demanded by the emerging\nautonomous systems, such as robotics. Beyond ensuring privacy-preserving\noperation and resilience in connectivity-limited environments, edge deployment\noffers significant energy and cost advantages over cloud-based solutions.\nHowever, deploying large language models (LLMs) for reasoning tasks on edge\nGPUs faces critical challenges from strict latency constraints and limited\ncomputational resources. To navigate these constraints, developers must balance\nmultiple design factors - choosing reasoning versus non-reasoning\narchitectures, selecting appropriate model sizes, allocating token budgets, and\napplying test-time scaling strategies - to meet target latency and optimize\naccuracy. Yet guidance on optimal combinations of these variables remains\nscarce. In this work, we present EdgeReasoning, a comprehensive study\ncharacterizing the deployment of reasoning LLMs on edge GPUs. We systematically\nquantify latency-accuracy tradeoffs across various LLM architectures and model\nsizes. We systematically evaluate prompt-based and model-tuning-based\ntechniques for reducing reasoning token length while maintaining performance\nquality. We further profile test-time scaling methods with varying degrees of\nparallelism to maximize accuracy under strict latency budgets. Through these\nanalyses, EdgeReasoning maps the Pareto frontier of achievable accuracy-latency\nconfigurations, offering systematic guidance for optimal edge deployment of\nreasoning LLMs.", "AI": {"tldr": "EdgeReasoning is a comprehensive study that characterizes the deployment of reasoning LLMs on edge GPUs, systematically quantifying latency-accuracy tradeoffs and providing guidance for optimal edge deployment.", "motivation": "Edge intelligence is increasingly demanded by autonomous systems like robotics, offering privacy, resilience, and cost advantages over cloud solutions. However, deploying LLMs for reasoning tasks on edge GPUs faces challenges from strict latency constraints and limited computational resources, with scarce guidance on optimal design combinations.", "method": "The study systematically quantifies latency-accuracy tradeoffs across various LLM architectures and model sizes, evaluates prompt-based and model-tuning techniques for reducing reasoning token length while maintaining performance, and profiles test-time scaling methods with varying parallelism to maximize accuracy under strict latency budgets.", "result": "EdgeReasoning maps the Pareto frontier of achievable accuracy-latency configurations, offering systematic guidance for optimal edge deployment of reasoning LLMs by analyzing various design factors including reasoning vs non-reasoning architectures, model sizes, token budgets, and test-time scaling strategies.", "conclusion": "The work provides comprehensive characterization of reasoning LLM deployment on edge GPUs, offering systematic guidance to help developers balance multiple design factors and navigate the constraints of latency and computational resources to achieve optimal performance in edge intelligence applications."}}
{"id": "2511.02196", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2511.02196", "abs": "https://arxiv.org/abs/2511.02196", "authors": ["Liwei Ni", "Jiaxi Zhang", "Shenggen Zheng", "Junfeng Liu", "Xingyu Meng", "Biwei Xie", "Xingquan Li", "Huawei Li"], "title": "BoolSkeleton: Boolean Network Skeletonization via Homogeneous Pattern Reduction", "comment": null, "summary": "Boolean equivalence allows Boolean networks with identical functionality to\nexhibit diverse graph structures. This gives more room for exploration in logic\noptimization, while also posing a challenge for tasks involving consistency\nbetween Boolean networks. To tackle this challenge, we introduce BoolSkeleton,\na novel Boolean network skeletonization method that improves the consistency\nand reliability of design-specific evaluations. BoolSkeleton comprises two key\nsteps: preprocessing and reduction. In preprocessing, the Boolean network is\ntransformed into a defined Boolean dependency graph, where nodes are assigned\nthe functionality-related status. Next, the homogeneous and heterogeneous\npatterns are defined for the node-level pattern reduction step. Heterogeneous\npatterns are preserved to maintain critical functionality-related dependencies,\nwhile homogeneous patterns can be reduced. Parameter K of the pattern further\nconstrains the fanin size of these patterns, enabling fine-tuned control over\nthe granularity of graph reduction. To validate BoolSkeleton's effectiveness,\nwe conducted four analysis/downstream tasks around the Boolean network:\ncompression analysis, classification, critical path analysis, and timing\nprediction, demonstrating its robustness across diverse scenarios. Furthermore,\nit improves above 55% in the average accuracy compared to the original Boolean\nnetwork for the timing prediction task. These experiments underscore the\npotential of BoolSkeleton to enhance design consistency in logic synthesis.", "AI": {"tldr": "BoolSkeleton is a Boolean network skeletonization method that improves consistency and reliability in design-specific evaluations by transforming networks into Boolean dependency graphs and applying pattern-based reduction while preserving critical functionality.", "motivation": "Boolean equivalence allows networks with identical functionality to have different graph structures, creating challenges for consistency between Boolean networks in logic optimization tasks.", "method": "Two-step approach: preprocessing transforms Boolean networks into Boolean dependency graphs with functionality-related node status, then pattern reduction applies homogeneous and heterogeneous patterns with parameter K controlling fanin size for granular graph reduction.", "result": "Validated through four analysis tasks (compression analysis, classification, critical path analysis, timing prediction), showing robustness across scenarios and achieving over 55% improvement in average accuracy for timing prediction compared to original Boolean networks.", "conclusion": "BoolSkeleton demonstrates potential to enhance design consistency in logic synthesis by providing reliable skeletonization that maintains critical functionality while improving evaluation consistency."}}
{"id": "2511.01871", "categories": ["cs.DC", "68M15, 93B12"], "pdf": "https://arxiv.org/pdf/2511.01871", "abs": "https://arxiv.org/abs/2511.01871", "authors": ["S. Tsiramua", "H. Meladze", "T. Davitashvili", "J. M. Sanchez", "F. Criado-Aldeanueva"], "title": "Structural Analysis of Multi-Core Processor and Reliability Evaluation Model", "comment": null, "summary": "In the present paper, the models of structural analysis and evaluation of\nefficiency indicators (reliability, fault tolerance, viability, and\nflexibility) of a multi core processor with variable structure, equipped with\nmulti functional cores, are considered. Using logical probabilistic methods,\nthe following has been developed: models for evaluating the reliability and\nfault tolerance of processor cores as multi functional elements; logical\nprobabilistic models of the shortest paths, flexibility, and performance\nconditions for successful operation of multi core processors based on multi\nfunctional cores; and models for estimating the reliability, fault tolerance,\nand lifetime of multi core processors considering all possible states of\nperformance. The results of the structural analysis of two core and four core\nprocessors and the trends of increasing the efficiency indicators of multi core\nprocessors are presented.", "AI": {"tldr": "This paper develops models for analyzing multi-core processors with variable structure and multi-functional cores, focusing on reliability, fault tolerance, viability, and flexibility using logical probabilistic methods.", "motivation": "To analyze and evaluate efficiency indicators (reliability, fault tolerance, viability, flexibility) of multi-core processors with variable structure and multi-functional cores, addressing the need for comprehensive performance assessment in modern processor architectures.", "method": "Using logical probabilistic methods to develop models for: reliability and fault tolerance evaluation of processor cores as multi-functional elements; logical probabilistic models of shortest paths, flexibility, and performance conditions; and models for estimating reliability, fault tolerance, and lifetime considering all possible performance states.", "result": "The paper presents results of structural analysis for two-core and four-core processors, along with trends showing increasing efficiency indicators for multi-core processors.", "conclusion": "The developed models provide comprehensive tools for evaluating the efficiency and performance characteristics of multi-core processors with variable structure and multi-functional cores, demonstrating improved efficiency indicators through structural analysis."}}
{"id": "2511.02269", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.02269", "abs": "https://arxiv.org/abs/2511.02269", "authors": ["Takuto Ando", "Yu Eto", "Ayumu Takeuchi", "Yasuhiko Nakashima"], "title": "Energy-Efficient Hardware Acceleration of Whisper ASR on a CGLA", "comment": "This paper is accepted at The Thirteenth International Symposium on\n  Computing and Networking (CANDAR2025)", "summary": "The rise of generative AI for tasks like Automatic Speech Recognition (ASR)\nhas created a critical energy consumption challenge. While ASICs offer high\nefficiency, they lack the programmability to adapt to evolving algorithms. To\naddress this trade-off, we implement and evaluate Whisper's core computational\nkernel on the IMAX, a general-purpose Coarse-Grained Linear Arrays (CGLAs)\naccelerator. To our knowledge, this is the first work to execute a Whisper\nkernel on a CGRA and compare its performance against CPUs and GPUs. Using\nhardware/software co-design, we evaluate our system via an FPGA prototype and\nproject performance for a 28 nm ASIC. Our results demonstrate superior energy\nefficiency. The projected ASIC is 1.90x more energy-efficient than the NVIDIA\nJetson AGX Orin and 9.83x more than an NVIDIA RTX 4090 for the Q8_0 model. This\nwork positions CGLA as a promising platform for sustainable ASR on\npower-constrained edge devices.", "AI": {"tldr": "This paper implements Whisper's core computational kernel on the IMAX CGLA accelerator, demonstrating superior energy efficiency compared to CPUs and GPUs for ASR tasks.", "motivation": "Address the trade-off between energy efficiency and programmability in generative AI for Automatic Speech Recognition, where ASICs are efficient but inflexible while general-purpose processors are programmable but less efficient.", "method": "Hardware/software co-design approach implementing Whisper's core kernel on the IMAX CGLA accelerator, evaluated via FPGA prototype and projected for 28 nm ASIC implementation.", "result": "The projected ASIC achieves 1.90x higher energy efficiency than NVIDIA Jetson AGX Orin and 9.83x higher than NVIDIA RTX 4090 for the Q8_0 model.", "conclusion": "CGLA platforms are promising for sustainable ASR on power-constrained edge devices, offering both energy efficiency and programmability."}}
{"id": "2511.01872", "categories": ["cs.DC", "cs.LG", "cs.PL"], "pdf": "https://arxiv.org/pdf/2511.01872", "abs": "https://arxiv.org/abs/2511.01872", "authors": ["Etash Guha", "Tianxiao Jiang", "Andrew Deng", "Jian Zhang", "Muthu Annamalai"], "title": "Learned Cost Model for Placement on Reconfigurable Dataflow Hardware", "comment": "7 pages, 2 figures, 2 tables, DAC Conference style (2022)", "summary": "Mapping a dataflow-graph of an ML model onto a reconfigurable system is\ndifficult, as different mappings have different throughputs and consume\nresource constraints differently. To solve this, a model to evaluate the\nthroughput of mappings is necessary as measuring throughput completely is\nexpensive. Many use a hand-designed analytical model, relying on proxy features\nor intuition, introducing error. We provide a Learned Approach that predicts\nthroughput 31%-52% more accurately over a variety of graphs. In addition, our\napproach shows no accuracy degradation after removing performance annotations.\nWe show that using this approach results in 5.6% faster compiled graphs.", "AI": {"tldr": "A learned approach for predicting throughput of ML model mappings on reconfigurable systems, achieving 31%-52% higher accuracy than hand-designed analytical models and resulting in 5.6% faster compiled graphs.", "motivation": "Mapping ML model dataflow graphs to reconfigurable systems is challenging due to varying throughput and resource constraints. Existing hand-designed analytical models rely on proxy features or intuition, introducing significant error in throughput prediction.", "method": "Developed a learned approach that predicts throughput of different mappings without requiring expensive complete measurements. The approach maintains accuracy even after removing performance annotations.", "result": "The learned approach predicts throughput 31%-52% more accurately across various graphs compared to traditional hand-designed analytical models. It shows no accuracy degradation when performance annotations are removed.", "conclusion": "Using this learned throughput prediction approach leads to 5.6% faster compiled graphs, demonstrating its practical effectiveness for optimizing ML model mappings on reconfigurable systems."}}
{"id": "2511.02285", "categories": ["cs.AR", "cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2511.02285", "abs": "https://arxiv.org/abs/2511.02285", "authors": ["Zhuorui Zhao", "Bing Li", "Grace Li Zhang", "Ulf Schlichtmann"], "title": "VFocus: Better Verilog Generation from Large Language Model via Focused Reasoning", "comment": "accepted by SOCC 2025", "summary": "Large Language Models (LLMs) have shown impressive potential in generating\nVerilog codes, but ensuring functional correctness remains a challenge.\nExisting approaches often rely on self-consistency or simulation feedback to\nselect the best candidate, but they miss opportunities to focus LLM reasoning\non the most informative parts of the design. We propose VFocus, a three-stage\nframework that enhances Verilog generation by sharpening the focus of LLM\nreasoning onto critical decision points in the code generation process. In the\n\\textbf{pre-ranking stage}, VFocus generates multiple code candidates through\nLLM prompting, retries for syntactically valid outputs, and introduces a\n\\textit{Density-guided Filtering} to retain candidates that fall within the\n\"reasoning sweet spot\" for functional correctness. In the \\textbf{ranking\nstage}, we simulate each code candidate using an automatically generated\ntestbench and apply self-consistency-based clustering to identify the most\nconsistent outputs. Finally, in the \\textbf{post-ranking refinement stage},\nVFocus performs inconsistency mining on top-ranked candidates and invokes\nreasoning-augmented LLM prompts for candidate refinement. Experiments on the\nVerilogEval-Human benchmark show that VFocus significantly improves the pass@1\ncorrectness across multiple reasoning LLMs, demonstrating its effectiveness in\nenhancing Verilog generation for complex hardware design tasks.", "AI": {"tldr": "VFocus is a three-stage framework that improves Verilog code generation by focusing LLM reasoning on critical decision points, using density-guided filtering, simulation-based ranking, and inconsistency mining for refinement.", "motivation": "Existing approaches for LLM-based Verilog generation miss opportunities to focus reasoning on the most informative parts of the design, leading to challenges in ensuring functional correctness.", "method": "Three-stage framework: 1) Pre-ranking with density-guided filtering to retain candidates in the \"reasoning sweet spot\", 2) Ranking using simulation and self-consistency clustering, 3) Post-ranking refinement with inconsistency mining and reasoning-augmented prompts.", "result": "Significant improvement in pass@1 correctness on the VerilogEval-Human benchmark across multiple reasoning LLMs.", "conclusion": "VFocus effectively enhances Verilog generation for complex hardware design tasks by sharpening LLM reasoning focus on critical decision points."}}
{"id": "2511.01881", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.01881", "abs": "https://arxiv.org/abs/2511.01881", "authors": ["Zhengxin Fang", "Hui Ma", "Gang Chen", "Rajkumar Buyya"], "title": "HGraphScale: Hierarchical Graph Learning for Autoscaling Microservice Applications in Container-based Cloud Computing", "comment": null, "summary": "Microservice architecture has become a dominant paradigm in application\ndevelopment due to its advantages of being lightweight, flexible, and\nresilient. Deploying microservice applications in the container-based cloud\nenables fine-grained elastic resource allocation. Autoscaling is an effective\napproach to dynamically adjust the resource provisioned to containers. However,\nthe intricate microservice dependencies and the deployment scheme of the\ncontainer-based cloud bring extra challenges of resource scaling. This article\nproposes a novel autoscaling approach named HGraphScale. In particular,\nHGraphScale captures microservice dependencies and the deployment scheme by a\nnewly designed hierarchical graph neural network, and makes effective scaling\nactions for rapidly changing user requests workloads. Extensive experiments\nbased on real-world traces of user requests are conducted to evaluate the\neffectiveness of HGraphScale. The experiment results show that the HGraphScale\noutperforms existing state-of-the-art autoscaling approaches by reducing at\nmost 80.16\\% of the average response time under a certain VM rental budget of\napplication providers.", "AI": {"tldr": "HGraphScale is a novel autoscaling approach for microservice applications in container-based clouds that uses hierarchical graph neural networks to capture microservice dependencies and deployment schemes, achieving significant improvements in response time under budget constraints.", "motivation": "Microservice architecture provides lightweight, flexible, and resilient application development, but the intricate dependencies between microservices and container deployment schemes create challenges for effective resource scaling in cloud environments.", "method": "Proposes HGraphScale approach that uses a hierarchical graph neural network to model microservice dependencies and deployment schemes, enabling effective scaling decisions for rapidly changing user request workloads.", "result": "Extensive experiments with real-world traces show HGraphScale reduces average response time by up to 80.16% compared to state-of-the-art autoscaling approaches under the same VM rental budget constraints.", "conclusion": "HGraphScale effectively addresses the challenges of autoscaling in microservice-based container clouds by leveraging hierarchical graph neural networks to capture complex dependencies and deployment schemes, delivering superior performance in response time reduction."}}
{"id": "2511.02408", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.02408", "abs": "https://arxiv.org/abs/2511.02408", "authors": ["Takuto Ando", "Yusuke Inoue"], "title": "Facial Expression Recognition System Using DNN Accelerator with Multi-threading on FPGA", "comment": "This paper was published in the proceedings of the 2024 Twelfth\n  International Symposium on Computing and Networking Workshops (CANDARW)", "summary": "In this paper, we implement a stand-alone facial expression recognition\nsystem on an SoC FPGA with multi-threading using a Deep learning Processor Unit\n(DPU). The system consists of two steps: one for face detection step and one\nfor facial expression recognition. In the previous work, the Haar Cascade\ndetector was run on a CPU in the face detection step due to FPGA resource\nlimitations, but this detector is less accurate for profile and variable\nillumination condition images. Moreover, the previous work used a dedicated\ncircuit accelerator, so running a second DNN inference for face detection on\nthe FPGA would require the addition of a new accelerator. As an alternative to\nthis approach, we run the two inferences by DNN on a DPU, which is a\ngeneral-purpose CNN accelerator of the systolic array type. Our method for face\ndetection using DenseBox and facial expression recognition using CNN on the\nsame DPU enables the efficient use of FPGA resources while maintaining a small\ncircuit size. We also developed a multi-threading technique that improves the\noverall throughput while increasing the DPU utilization efficiency. With this\napproach, we achieved an overall system throughput of 25 FPS and a throughput\nper power consumption of 2.4 times.", "AI": {"tldr": "Implementation of a facial expression recognition system on SoC FPGA using DPU with multi-threading, achieving 25 FPS throughput and 2.4x power efficiency.", "motivation": "Previous work used Haar Cascade detector on CPU which was less accurate for profile and variable illumination conditions, and required separate accelerators for different DNN inferences.", "method": "Used DenseBox for face detection and CNN for facial expression recognition on the same DPU (systolic array CNN accelerator), with multi-threading to improve throughput and DPU utilization.", "result": "Achieved overall system throughput of 25 FPS and throughput per power consumption of 2.4 times.", "conclusion": "The proposed approach enables efficient use of FPGA resources while maintaining small circuit size and improves both performance and power efficiency."}}
{"id": "2511.01888", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.01888", "abs": "https://arxiv.org/abs/2511.01888", "authors": ["Cynthia Marcelino", "Thomas Pusztai", "Stefan Nastic"], "title": "Roadrunner: Accelerating Data Delivery to WebAssembly-Based Serverless Functions", "comment": "26th International Middleware Conference (MIDDLEWARE 25)", "summary": "Serverless computing provides infrastructure management and elastic\nauto-scaling, therefore reducing operational overhead. By design serverless\nfunctions are stateless, which means they typically leverage external remote\nservices to store and exchange data. Transferring data over a network typically\ninvolves serialization and deserialization. These operations usually require\nmultiple data copies and transitions between user and kernel space, resulting\nin overhead from context switching and memory allocation, contributing\nsignificantly to increased latency and resource consumption. To address these\nissues, we present Roadrunner, a sidecar shim that enables near-zero copy and\nserialization-free data transfer between WebAssembly-based serverless\nfunctions. Roadrunner reduces the multiple copies between user space and kernel\nspace by mapping the function memory and moving the data along a dedicated\nvirtual data hose, bypassing the costly processes of serialization and\ndeserialization. This approach reduces data movement overhead and context\nswitching, achieving near-native latency performance for WebAssembly-based\nserverless functions. Our experimental results demonstrate that Roadrunner\nsignificantly improves the inter-function communication latency from 44% up to\n89%, reducing the serialization overhead in 97% of data transfer, and\nincreasing throughput by 69 times compared to state-of-the-art\nWebAssembly-based serverless functions.", "AI": {"tldr": "Roadrunner is a sidecar shim that enables near-zero copy and serialization-free data transfer between WebAssembly-based serverless functions, significantly reducing latency and improving throughput.", "motivation": "Serverless functions are stateless and rely on external services for data storage/exchange, which involves costly serialization/deserialization operations with multiple data copies and context switching, leading to increased latency and resource consumption.", "method": "Roadrunner reduces data copies by mapping function memory and moving data along a dedicated virtual data hose, bypassing serialization/deserialization processes to achieve near-native latency performance.", "result": "Roadrunner improves inter-function communication latency by 44-89%, reduces serialization overhead in 97% of data transfers, and increases throughput by 69 times compared to state-of-the-art WebAssembly-based serverless functions.", "conclusion": "Roadrunner effectively addresses data transfer overhead in serverless computing by enabling near-zero copy communication, significantly improving performance metrics for WebAssembly-based serverless functions."}}
{"id": "2511.02494", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.02494", "abs": "https://arxiv.org/abs/2511.02494", "authors": ["Raul Murillo", "Julio Villalba-Moreno", "Alberto A. Del Barrio", "Guillermo Botella"], "title": "Digit-Recurrence Posit Division", "comment": "11 pages, 9 figures", "summary": "Posit arithmetic has emerged as a promising alternative to IEEE 754\nfloating-point representation, offering enhanced accuracy and dynamic range.\nHowever, division operations in posit systems remain challenging due to their\ninherent hardware complexity. In this work, we present posit division units\nbased on the digit-recurrence algorithm, marking the first implementation of\nradix-4 digit-recurrence techniques within this context. Our approach\nincorporates hardware-centric optimizations including redundant arithmetic,\non-the-fly quotient conversion, and operand scaling to streamline the division\nprocess while mitigating latency, area, and power overheads. Comprehensive\nsynthesis evaluations across multiple posit configurations demonstrate\nsignificant performance improvements, including more than 80% energy reduction\nwith small area overhead compared to existing methods, and a substantial\ndecrease in the number of iterations. These results underscore the potential of\nour adapted algorithm to enhance the efficiency of posit-based arithmetic\nunits.", "AI": {"tldr": "First implementation of radix-4 digit-recurrence algorithm for posit division, achieving >80% energy reduction with small area overhead and fewer iterations compared to existing methods.", "motivation": "Posit arithmetic offers better accuracy and dynamic range than IEEE 754 floating-point, but division operations remain challenging due to hardware complexity. Existing posit division methods need improvement in efficiency.", "method": "Used digit-recurrence algorithm with radix-4 implementation, incorporating hardware optimizations like redundant arithmetic, on-the-fly quotient conversion, and operand scaling to reduce latency, area, and power.", "result": "Significant performance improvements across multiple posit configurations: >80% energy reduction with small area overhead, substantial decrease in iteration count compared to existing methods.", "conclusion": "The adapted digit-recurrence algorithm demonstrates strong potential to enhance efficiency of posit-based arithmetic units, making posit division more practical and energy-efficient."}}
{"id": "2511.01893", "categories": ["cs.DC", "cs.PF"], "pdf": "https://arxiv.org/pdf/2511.01893", "abs": "https://arxiv.org/abs/2511.01893", "authors": ["Bin Ma", "Viktor Nikitin", "Xi Wang", "Tekin Bicer", "Dong Li"], "title": "mLR: Scalable Laminography Reconstruction based on Memoization", "comment": null, "summary": "ADMM-FFT is an iterative method with high reconstruction accuracy for\nlaminography but suffers from excessive computation time and large memory\nconsumption. We introduce mLR, which employs memoization to replace the\ntime-consuming Fast Fourier Transform (FFT) operations based on an unique\nobservation that similar FFT operations appear in iterations of ADMM-FFT. We\nintroduce a series of techniques to make the application of memoization to\nADMM-FFT performance-beneficial and scalable. We also introduce variable\noffloading to save CPU memory and scale ADMM-FFT across GPUs within and across\nnodes. Using mLR, we are able to scale ADMM-FFT on an input problem of\n2Kx2Kx2K, which is the largest input problem laminography reconstruction has\never worked on with the ADMM-FFT solution on limited memory; mLR brings 52.8%\nperformance improvement on average (up to 65.4%), compared to the original\nADMM-FFT.", "AI": {"tldr": "mL-R introduces memoization and variable offloading to optimize ADMM-FFT laminography reconstruction, achieving 52.8% average performance improvement while enabling scaling to 2Kx2Kx2K problems.", "motivation": "ADMM-FFT provides high reconstruction accuracy for laminography but suffers from excessive computation time and large memory consumption, limiting its scalability.", "method": "mL-R employs memoization to replace time-consuming FFT operations by leveraging the observation that similar FFT operations appear in ADMM-FFT iterations. It uses techniques to make memoization performance-beneficial and scalable, plus variable offloading to save CPU memory and scale across GPUs.", "result": "mL-R enables scaling ADMM-FFT to 2Kx2Kx2K problems (largest ever for laminography reconstruction with ADMM-FFT) and achieves 52.8% average performance improvement (up to 65.4%) compared to original ADMM-FFT.", "conclusion": "mL-R successfully optimizes ADMM-FFT for laminography reconstruction through memoization and memory management techniques, significantly improving performance and enabling larger-scale reconstructions."}}
{"id": "2511.02530", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.02530", "abs": "https://arxiv.org/abs/2511.02530", "authors": ["Takuto Ando", "Yu Eto", "Yasuhiko Nakashima"], "title": "Implementation and Evaluation of Stable Diffusion on a General-Purpose CGLA Accelerator", "comment": "This paper is accepted at 2025 IEEE 18th International Symposium on\n  Embedded Multicore/Many-core Systems-on-Chip (MCSoC)", "summary": "This paper presents the first implementation and in-depth evaluation of the\nprimary computational kernels from the stable-diffusion.cpp image generation\nframework on IMAX3, a general-purpose Coarse-Grained Reconfigurable Array\n(CGRA) accelerator. We designed IMAX3 as a versatile computational platform,\nand this work assesses its capabilities by executing a demanding image\ngeneration workload. We evaluate its performance on a current\nField-Programmable Gate Array (FPGA) prototype to establish a baseline and\nproject its potential for a future Application-Specific Integrated Circuit\n(ASIC) implementation. Our results demonstrate that, despite its\ngeneral-purpose architecture, IMAX3 achieves promising performance and power\nefficiency, particularly in its projected ASIC form. This work provides\nconcrete guidelines for future IMAX architectural designs and establishes a\nfoundation for developing next-generation, AI-specialized Coarse-Grained Linear\nArray (CGLA) accelerators by refining this versatile platform. Ultimately, this\nachievement contributes to the realization of energy-efficient, on-device,\nmulti-modal AI platforms.", "AI": {"tldr": "First implementation and evaluation of stable-diffusion.cpp kernels on IMAX3 CGRA accelerator, showing promising performance and power efficiency for AI image generation workloads.", "motivation": "To assess the capabilities of the general-purpose IMAX3 CGRA accelerator by executing demanding image generation workloads and establish foundations for future AI-specialized accelerators.", "method": "Implemented primary computational kernels from stable-diffusion.cpp on IMAX3 CGRA, evaluated performance on FPGA prototype, and projected potential for future ASIC implementation.", "result": "IMAX3 achieved promising performance and power efficiency despite its general-purpose architecture, with particularly strong results projected for ASIC implementation.", "conclusion": "Provides guidelines for future IMAX architectural designs and contributes to developing energy-efficient, on-device, multi-modal AI platforms through refined versatile accelerator platforms."}}
{"id": "2511.02168", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.02168", "abs": "https://arxiv.org/abs/2511.02168", "authors": ["Octavian Alexandru Trifan", "Karthik Sangaiah", "Muhammad Awad", "Muhammad Osama", "Sumanth Gudaparthi", "Alexandru Nicolau", "Alexander Veidenbaum", "Ganesh Dasika"], "title": "Eliminating Multi-GPU Performance Taxes: A Systems Approach to Efficient Distributed LLMs", "comment": null, "summary": "As large language models (LLMs) continue to scale, their workloads\nincreasingly rely on distributed execution across multiple GPUs. However, the\nconventional bulk synchronous parallel~(BSP) model used in such settings\nintroduces significant performance inefficiencies. To characterize these\nbottlenecks, we introduce the ''Three Taxes'' (Bulk Synchronous, Inter-Kernel\nData Locality, and Kernel Launch Overhead) as an analytical framework. We\npropose moving beyond the rigid BSP model to address key inefficiencies in\ndistributed GPU execution. By exploiting libraries like Iris for Triton, we\ngain access to in-kernel communication primitives that enable the design of\nnovel fine-grained programming patterns, offering greater flexibility and\nperformance than traditional BSP-based approaches. These patterns\nsystematically eliminate the three taxes by creating direct, tile-level\nproducer-consumer pipelines and replacing global barriers with fine-grained\ndataflow synchronization. Applying this methodology to critical kernels, from\nthe foundational All-Gather + general matrix multiplication operation to the\ncomplex Flash Decode algorithm, we observe a 10-20% speedup in end-to-end\nlatency over BSP-based approaches, establishing a more programmable and\nefficient paradigm for distributed LLM workloads.", "AI": {"tldr": "The paper proposes moving beyond the bulk synchronous parallel (BSP) model to address inefficiencies in distributed GPU execution for large language models, introducing the 'Three Taxes' framework and novel fine-grained programming patterns that eliminate these taxes through direct tile-level pipelines and fine-grained dataflow synchronization.", "motivation": "As LLMs scale, distributed execution across multiple GPUs using conventional BSP model introduces significant performance inefficiencies that need to be addressed.", "method": "The authors exploit libraries like Iris for Triton to access in-kernel communication primitives, enabling design of novel fine-grained programming patterns that create direct tile-level producer-consumer pipelines and replace global barriers with fine-grained dataflow synchronization.", "result": "Applying this methodology to critical kernels (All-Gather + GEMM operation and Flash Decode algorithm) achieves 10-20% speedup in end-to-end latency over BSP-based approaches.", "conclusion": "The approach establishes a more programmable and efficient paradigm for distributed LLM workloads by systematically eliminating the three identified taxes."}}
{"id": "2511.02248", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.02248", "abs": "https://arxiv.org/abs/2511.02248", "authors": ["Xingqi Cui", "Chieh-Jan Mike Liang", "Jiarong Xing", "Haoran Qiu"], "title": "From Models to Operators: Rethinking Autoscaling Granularity for Large Generative Models", "comment": "16 pages, 13 figures", "summary": "Serving large generative models such as LLMs and multi- modal transformers\nrequires balancing user-facing SLOs (e.g., time-to-first-token,\ntime-between-tokens) with provider goals of efficiency and cost reduction.\nExisting solutions rely on static provisioning or model-level autoscaling, both\nof which treat the model as a monolith. This coarse-grained resource management\nleads to degraded performance or significant resource underutilization due to\npoor adaptability to dynamic inference traffic that is common online.\n  The root cause of this inefficiency lies in the internal structure of\ngenerative models: they are executed as graphs of interconnected operators.\nThrough detailed characterization and systematic analysis, we find that\noperators are heterogeneous in their compute and memory footprints and exhibit\ndiverse sensitivity to workload and resource factors such as batch size,\nsequence length, and traffic rate. This heterogeneity suggests that the\noperator, rather than the entire model, is the right granularity for scaling\ndecisions.\n  We propose an operator-level autoscaling framework, which allocates resources\nat finer (operator)-granularity, optimizing the scaling, batching, and\nplacement based on individual operator profiles. Evaluated on production-scale\ntraces, our approach preserves SLOs with up to 40% fewer GPUs and 35% less\nenergy, or under fixed resources achieves 1.6x higher throughput with 5% less\nenergy. These results show that the operator, rather than the model, is\nfundamentally a more effective unit for scaling large generative workloads.", "AI": {"tldr": "Proposes operator-level autoscaling for large generative models to improve efficiency while maintaining SLOs, achieving 40% GPU reduction and 35% energy savings.", "motivation": "Existing static provisioning and model-level autoscaling treat models as monoliths, leading to degraded performance and resource underutilization due to poor adaptability to dynamic inference traffic.", "method": "Operator-level autoscaling framework that allocates resources at finer granularity, optimizing scaling, batching, and placement based on individual operator profiles.", "result": "Preserves SLOs with up to 40% fewer GPUs and 35% less energy, or achieves 1.6x higher throughput with 5% less energy under fixed resources.", "conclusion": "The operator, rather than the entire model, is fundamentally a more effective unit for scaling large generative workloads."}}
{"id": "2511.02257", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.02257", "abs": "https://arxiv.org/abs/2511.02257", "authors": ["Oguz Selvitopi", "Emin Ozturk", "Jie Chen", "Ponnuswamy Sadayappan", "Robert G. Edwards", "Ayd\u0131n Bulu\u00e7"], "title": "Fast Algorithms for Scheduling Many-body Correlation Functions on Accelerators", "comment": null, "summary": "Computation of correlation functions is a key operation in Lattice quantum\nchromodynamics (LQCD) simulations to extract nuclear physics observables. These\nfunctions involve many binary batch tensor contractions, each tensor possibly\noccupying hundreds of MBs of memory. Performing these contractions on GPU\naccelerators poses the challenge of scheduling them as to optimize tensor reuse\nand reduce data traffic. In this work we propose two fast novel scheduling\nalgorithms that reorder contractions to increase temporal locality via\ninput/intermediate tensor reuse. Our schedulers take advantage of\napplication-specific features, such as contractions being binary and locality\nwithin contraction trees, to optimize the objective of minimizing peak memory.\nWe integrate them into the LQCD analysis software suite Redstar and improve\ntime-to-solution. Our schedulers attain upto 2.1x improvement in peak memory,\nwhich is reflected by a reduction of upto 4.2x in evictions, upto 1.8x in data\ntraffic, resulting in upto 1.9x faster correlation function computation time.", "AI": {"tldr": "The paper presents two novel scheduling algorithms for optimizing tensor contractions in Lattice QCD simulations, focusing on improving temporal locality and reducing peak memory usage through better tensor reuse.", "motivation": "LQCD simulations require computing correlation functions involving many large tensor contractions that consume significant GPU memory. Current approaches face challenges in scheduling these contractions efficiently to optimize tensor reuse and minimize data movement.", "method": "Proposed two fast scheduling algorithms that reorder binary batch tensor contractions to increase temporal locality via input/intermediate tensor reuse. The schedulers leverage application-specific features like binary contractions and locality within contraction trees to minimize peak memory usage.", "result": "The schedulers achieved up to 2.1x improvement in peak memory, up to 4.2x reduction in evictions, up to 1.8x reduction in data traffic, and up to 1.9x faster correlation function computation time when integrated into the Redstar LQCD analysis software.", "conclusion": "The proposed scheduling algorithms effectively optimize tensor contractions in LQCD simulations by improving temporal locality and reducing memory requirements, leading to significant performance improvements in correlation function computation."}}
{"id": "2511.02293", "categories": ["cs.DC", "cs.CV", "C.2.4; I.2.10"], "pdf": "https://arxiv.org/pdf/2511.02293", "abs": "https://arxiv.org/abs/2511.02293", "authors": ["Taisuke Noguchi", "Takuya Azumi"], "title": "3D Point Cloud Object Detection on Edge Devices for Split Computing", "comment": "6 pages. This version includes minor lstlisting configuration\n  adjustments for successful compilation. No changes to content or layout.\n  Originally published at ACM/IEEE RAGE 2024", "summary": "The field of autonomous driving technology is rapidly advancing, with deep\nlearning being a key component. Particularly in the field of sensing, 3D point\ncloud data collected by LiDAR is utilized to run deep neural network models for\n3D object detection. However, these state-of-the-art models are complex,\nleading to longer processing times and increased power consumption on edge\ndevices. The objective of this study is to address these issues by leveraging\nSplit Computing, a distributed machine learning inference method. Split\nComputing aims to lessen the computational burden on edge devices, thereby\nreducing processing time and power consumption. Furthermore, it minimizes the\nrisk of data breaches by only transmitting intermediate data from the deep\nneural network model. Experimental results show that splitting after\nvoxelization reduces the inference time by 70.8% and the edge device execution\ntime by 90.0%. When splitting within the network, the inference time is reduced\nby up to 57.1%, and the edge device execution time is reduced by up to 69.5%.", "AI": {"tldr": "This paper proposes using Split Computing to reduce processing time and power consumption for 3D object detection in autonomous driving by distributing neural network inference between edge devices and cloud servers.", "motivation": "State-of-the-art 3D object detection models using LiDAR point clouds are computationally intensive, causing long processing times and high power consumption on edge devices in autonomous driving systems.", "method": "The study leverages Split Computing, a distributed machine learning inference approach that splits deep neural network execution between edge devices and cloud servers, transmitting only intermediate data to reduce computational burden on edge devices.", "result": "Experimental results show significant improvements: splitting after voxelization reduces inference time by 70.8% and edge device execution time by 90.0%; splitting within the network reduces inference time by up to 57.1% and edge device execution time by up to 69.5%.", "conclusion": "Split Computing effectively addresses computational challenges in 3D object detection for autonomous driving by reducing processing time and power consumption on edge devices while maintaining data security through transmission of only intermediate network data."}}
{"id": "2511.02647", "categories": ["cs.DC", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2511.02647", "abs": "https://arxiv.org/abs/2511.02647", "authors": ["Xiumei Deng", "Zehui Xiong", "Binbin Chen", "Dong In Kim", "Merouane Debbah", "H. Vincent Poor"], "title": "Federated Attention: A Distributed Paradigm for Collaborative LLM Inference over Edge Networks", "comment": null, "summary": "Large language models (LLMs) are proliferating rapidly at the edge,\ndelivering intelligent capabilities across diverse application scenarios.\nHowever, their practical deployment in collaborative scenarios confronts\nfundamental challenges: privacy vulnerabilities, communication overhead, and\ncomputational bottlenecks. To address these, we propose Federated Attention\n(FedAttn), which integrates the federated paradigm into the self-attention\nmechanism, creating a new distributed LLM inference framework that\nsimultaneously achieves privacy protection, communication efficiency, and\ncomputational efficiency. FedAttn enables participants to perform local\nself-attention over their own token representations while periodically\nexchanging and aggregating Key-Value (KV) matrices across multiple Transformer\nblocks, collaboratively generating LLM responses without exposing private\nprompts. Further, we identify a structural duality between contextual\nrepresentation refinement in FedAttn and parameter optimization in FL across\nprivate data, local computation, and global aggregation. This key insight\nprovides a principled foundation for systematically porting federated\noptimization techniques to collaborative LLM inference. Building on this\nframework, we theoretically analyze how local self-attention computation within\nparticipants and heterogeneous token relevance among participants shape error\npropagation dynamics across Transformer blocks. Moreover, we characterize the\nfundamental trade-off between response quality and communication/computation\nefficiency, which is governed by the synchronization interval and the number of\nparticipants. Experimental results validate our theoretical analysis, and\nreveal significant optimization opportunities through sparse attention and\nadaptive KV aggregation, highlighting FedAttn's potential to deliver\nscalability and efficiency in real-world edge deployments.", "AI": {"tldr": "FedAttn is a federated attention framework that integrates federated learning into self-attention mechanisms for distributed LLM inference, achieving privacy protection, communication efficiency, and computational efficiency by allowing local self-attention with periodic KV matrix exchange.", "motivation": "Address privacy vulnerabilities, communication overhead, and computational bottlenecks in deploying LLMs at the edge for collaborative scenarios.", "method": "Integrate federated paradigm into self-attention mechanism, enabling participants to perform local self-attention over their own tokens while periodically exchanging and aggregating KV matrices across Transformer blocks.", "result": "Theoretical analysis reveals error propagation dynamics shaped by local self-attention and heterogeneous token relevance, and characterizes trade-off between response quality and communication/computation efficiency. Experimental results validate analysis and show optimization opportunities through sparse attention and adaptive KV aggregation.", "conclusion": "FedAttn provides a principled foundation for porting federated optimization techniques to collaborative LLM inference, demonstrating potential for scalability and efficiency in real-world edge deployments."}}
{"id": "2511.02655", "categories": ["cs.DC", "cs.MS"], "pdf": "https://arxiv.org/pdf/2511.02655", "abs": "https://arxiv.org/abs/2511.02655", "authors": ["Johansell Villalobos", "Josef Ruzicka", "Silvio Rizzi"], "title": "Implementing Multi-GPU Scientific Computing Miniapps Across Performance Portable Frameworks", "comment": null, "summary": "Scientific computing in the exascale era demands increased computational\npower to solve complex problems across various domains. With the rise of\nheterogeneous computing architectures the need for vendor-agnostic, performance\nportability frameworks has been highlighted. Libraries like Kokkos have become\nessential for enabling high-performance computing applications to execute\nefficiently across different hardware platforms with minimal code changes. In\nthis direction, this paper presents preliminary time-to-solution results for\ntwo representative scientific computing applications: an N-body simulation and\na structured grid simulation. Both applications used a distributed memory\napproach and hardware acceleration through four performance portability\nframeworks: Kokkos, OpenMP, RAJA, and OCCA. Experiments conducted on a single\nnode of the Polaris supercomputer using four NVIDIA A100 GPUs revealed\nsignificant performance variability among frameworks. OCCA demonstrated faster\nexecution times for small-scale validation problems, likely due to JIT\ncompilation, however its lack of optimized reduction algorithms may limit\nscalability for larger simulations while using its out of the box API. OpenMP\nperformed poorly in the structured grid simulation most likely due to\ninefficiencies in inter-node data synchronization and communication. These\nfindings highlight the need for further optimization to maximize each\nframework's capabilities. Future work will focus on enhancing reduction\nalgorithms, data communication, memory management, as wells as performing\nscalability studies, and a comprehensive statistical analysis to evaluate and\ncompare framework performance.", "AI": {"tldr": "This paper compares four performance portability frameworks (Kokkos, OpenMP, RAJA, OCCA) for scientific computing applications on GPU hardware, finding significant performance variability and highlighting optimization needs.", "motivation": "The rise of heterogeneous computing architectures creates demand for vendor-agnostic performance portability frameworks to enable efficient execution of scientific computing applications across different hardware platforms with minimal code changes.", "method": "The study evaluated two scientific applications (N-body simulation and structured grid simulation) using distributed memory approach and hardware acceleration through four frameworks on a Polaris supercomputer node with four NVIDIA A100 GPUs.", "result": "OCCA showed faster execution for small-scale problems due to JIT compilation but lacks optimized reduction algorithms. OpenMP performed poorly in structured grid simulations due to inefficient data synchronization. Significant performance variability was observed among frameworks.", "conclusion": "Further optimization is needed to maximize each framework's capabilities, particularly for reduction algorithms, data communication, and memory management. Future work will focus on scalability studies and comprehensive statistical analysis."}}
{"id": "2511.02743", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2511.02743", "abs": "https://arxiv.org/abs/2511.02743", "authors": ["Fedor Ryabinin", "Alexey Gotsman", "Pierre Sutra"], "title": "Making Democracy Work: Fixing and Simplifying Egalitarian Paxos (Extended Version)", "comment": "Extended version of a paper in OPODIS'25: International Conference on\n  Principles of Distributed Systems", "summary": "Classical state-machine replication protocols, such as Paxos, rely on a\ndistinguished leader process to order commands. Unfortunately, this approach\nmakes the leader a single point of failure and increases the latency for\nclients that are not co-located with it. As a response to these drawbacks,\nEgalitarian Paxos introduced an alternative, leaderless approach, that allows\nreplicas to order commands collaboratively. Not relying on a single leader\nallows the protocol to maintain non-zero throughput with up to $f$ crashes of\nany processes out of a total of $n = 2f+1$. The protocol furthermore allows any\nprocess to execute a command $c$ fast, in $2$ message delays, provided no more\nthan $e = \\lceil\\frac{f+1}{2}\\rceil$ other processes fail, and all concurrently\nsubmitted commands commute with $c$; the latter condition is often satisfied in\npractical systems.\n  Egalitarian Paxos has served as a foundation for many other replication\nprotocols. But unfortunately, the protocol is very complex, ambiguously\nspecified and suffers from nontrivial bugs. In this paper, we present EPaxos*\n-- a simpler and correct variant of Egalitarian Paxos. Our key technical\ncontribution is a simpler failure-recovery algorithm, which we have rigorously\nproved correct. Our protocol also generalizes Egalitarian Paxos to cover the\nwhole spectrum of failure thresholds $f$ and $e$ such that $n \\ge \\max\\{2e+f-1,\n2f+1\\}$ -- the number of processes that we show to be optimal.", "AI": {"tldr": "EPaxos* is a simpler and correct variant of Egalitarian Paxos that addresses complexity and correctness issues in the original leaderless replication protocol, while generalizing it to optimal process counts.", "motivation": "Egalitarian Paxos introduced leaderless state-machine replication to avoid single points of failure and reduce latency, but suffered from complexity, ambiguous specification, and nontrivial bugs that needed addressing.", "method": "The paper presents EPaxos* with a simpler failure-recovery algorithm that has been rigorously proved correct, and generalizes the protocol to cover optimal failure thresholds where n \u2265 max{2e+f-1, 2f+1}.", "result": "EPaxos* maintains the benefits of leaderless replication (non-zero throughput with up to f crashes, fast 2-message-delay execution under certain conditions) while being simpler and provably correct.", "conclusion": "EPaxos* successfully addresses the complexity and correctness issues of Egalitarian Paxos while preserving its advantages and achieving optimal process counts for the generalized failure thresholds."}}
