<div id=toc></div>

# Table of Contents

- [cs.DC](#cs.DC) [Total: 8]
- [cs.AR](#cs.AR) [Total: 3]


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [1] [ParaCodex: A Profiling-Guided Autonomous Coding Agent for Reliable Parallel Code Generation and Translation](https://arxiv.org/abs/2601.04327)
*Erel Kaplan,Tomer Bitan,Lian Ghrayeb,Le Chen,Tom Yotam,Niranjan Hasabnis,Gal Oren*

Main category: cs.DC

TL;DR: ParaCodex is an autonomous system that translates serial CPU kernels to optimized OpenMP GPU offload code using staged analysis, data planning, and profiling-guided refinement, achieving significant speedups over reference implementations.


<details>
  <summary>Details</summary>
Motivation: Parallel programming for HPC and AI, particularly OpenMP GPU offload, is challenging due to complex data movement and tuning requirements. Existing autonomous coding agents produce brittle outputs without proper domain-specific scaffolding.

Method: ParaCodex uses a Codex-based agent with staged hotspot analysis, explicit data planning, correctness gating, and profiling-guided refinement to autonomously generate OpenMP GPU offload kernels from serial CPU code.

Result: Successfully translated 31/31 valid kernels from HeCBench, Rodinia, and NAS benchmarks, achieving geometric-mean speedups of 3x on HeCBench and 5x on Rodinia, outperforming reference OpenMP implementations in 25/31 cases and beating zero-shot Codex baselines.

Conclusion: ParaCodex demonstrates that autonomous coding agents with proper HPC engineering workflows can effectively generate optimized OpenMP GPU offload code, significantly improving performance while maintaining correctness.

Abstract: Parallel programming is central to HPC and AI, but producing code that is correct and fast remains challenging, especially for OpenMP GPU offload, where data movement and tuning dominate. Autonomous coding agents can compile, test, and profile on target hardware, but outputs are brittle without domain scaffolding.
  We present ParaCodex, an HPC-engineer workflow that turns a Codex-based agent into an autonomous OpenMP GPU offload system using staged hotspot analysis, explicit data planning, correctness gating, and profiling-guided refinement. We evaluate translation from serial CPU kernels to OpenMP GPU offload kernels on HeCBench, Rodinia, and NAS. After excluding five kernels, ParaCodex succeeded on all 31 valid kernels. The generated kernels improved GPU time over reference OpenMP implementations in 25/31 cases, achieving geometric-mean speedups of 3x on HeCBench and 5x on Rodinia, and outperforming a zero-shot Codex baseline on all suites. We also evaluate CUDA to OpenMP offload translation on ParEval, where ParaCodex maintains high compilation and validation rates in code-only and end-to-end settings.

</details>


### [2] [Hybrid Cloud Architectures for Research Computing: Applications and Use Cases](https://arxiv.org/abs/2601.04349)
*Xaver Stiensmeier,Alexander Kanitz,Jan Krüger,Santiago Insua,Adrián Rošinec,Viktória Spišáková,Lukáš Hejtmánek,David Yuan,Gavin Farrell,Jonathan Tedds,Juha Törnroos,Harald Wagener,Alex Sczyrba,Nils Hoffmann,Matej Antol*

Main category: cs.DC

TL;DR: This paper provides a comprehensive overview of hybrid cloud deployment models for scientific research, focusing on integration strategies for grid/cloud platforms and workflow tools to address fragmented computing ecosystems.


<details>
  <summary>Details</summary>
Motivation: Scientific research faces challenges with fragmented IT infrastructures where researchers must navigate multiple computing environments (research infrastructures, NRENs, commercial clouds) while balancing performance, cost, scalability, and accessibility.

Method: The paper examines hybrid cloud deployment models, focusing on grid/cloud platforms (OpenPBS, SLURM, OpenStack, Kubernetes) and workflow management tools (Nextflow, Snakemake, CWL). It explores strategies for federated computing, multi-cloud orchestration, and workload scheduling.

Result: The paper draws on implementations from life sciences coordinated by the ELIXIR Compute Platform and their integration into the EOSC context, proposing solutions for interoperability, data security, reproducibility, and network performance challenges.

Conclusion: The paper proposes a roadmap for accelerating hybrid cloud adoption in research computing, emphasizing governance frameworks and technical solutions that can drive sustainable and scalable infrastructure development.

Abstract: Scientific research increasingly depends on robust and scalable IT infrastructures to support complex computational workflows. With the proliferation of services provided by research infrastructures, NRENs, and commercial cloud providers, researchers must navigate a fragmented ecosystem of computing environments, balancing performance, cost, scalability, and accessibility. Hybrid cloud architectures offer a compelling solution by integrating multiple computing environments to enhance flexibility, resource efficiency, and access to specialised hardware.
  This paper provides a comprehensive overview of hybrid cloud deployment models, focusing on grid and cloud platforms (OpenPBS, SLURM, OpenStack, Kubernetes) and workflow management tools (Nextflow, Snakemake, CWL). We explore strategies for federated computing, multi-cloud orchestration, and workload scheduling, addressing key challenges such as interoperability, data security, reproducibility, and network performance. Drawing on implementations from life sciences, as coordinated by the ELIXIR Compute Platform and their integration into a wider EOSC context, we propose a roadmap for accelerating hybrid cloud adoption in research computing, emphasising governance frameworks and technical solutions that can drive sustainable and scalable infrastructure development.

</details>


### [3] [Sharded Elimination and Combining for Highly-Efficient Concurrent Stacks](https://arxiv.org/abs/2601.04523)
*Ajay Singh,Nikos Metaxakis,Panagiota Fatourou*

Main category: cs.DC

TL;DR: A new concurrent stack implementation using sharding and fetch&increment achieves up to 2x better performance than existing stacks through novel elimination and combining techniques.


<details>
  <summary>Details</summary>
Motivation: Existing concurrent stack implementations suffer from performance limitations, especially in high-contention scenarios and systems with many threads. There's a need for better parallel access with reduced contention.

Method: Uses sharding and fetch&increment operations combined with a novel elimination mechanism and new combining approach to efficiently blend techniques for high performance.

Result: Outperforms all existing concurrent stacks by up to 2x in most workloads, with enhanced parallelism and low contention, particularly effective in high-thread systems and high-contention scenarios.

Conclusion: The proposed blocking linearizable stack implementation represents a significant performance improvement over existing concurrent stacks through innovative use of sharding, elimination, and combining techniques.

Abstract: We present a new blocking linearizable stack implementation which utilizes sharding and fetch&increment to achieve significantly better performance than all existing concurrent stacks. The proposed implementation is based on a novel elimination mechanism and a new combining approach that are efficiently blended to gain high performance. Our implementation results in enhanced parallelism and low contention when accessing the shared stack. Experiments show that the proposed stack implementation outperforms all existing concurrent stacks by up to 2X in most workloads. It is particularly efficient in systems supporting a large number of threads and in high contention scenarios.

</details>


### [4] [Quantifying Autoscaler Vulnerabilities: An Empirical Study of Resource Misallocation Induced by Cloud Infrastructure Faults](https://arxiv.org/abs/2601.04659)
*Gijun Park*

Main category: cs.DC

TL;DR: Faults in cloud infrastructure corrupt performance metrics, causing autoscalers to make poor provisioning decisions that increase costs or degrade reliability.


<details>
  <summary>Details</summary>
Motivation: Autoscaling mechanisms rely on accurate performance metrics to make optimal resource provisioning decisions. When infrastructure faults corrupt these metrics, autoscalers may systematically over- or under-provision resources, leading to increased operational expenses or degraded service reliability.

Method: The paper conducts controlled simulation experiments to measure how four prevalent fault categories affect both vertical and horizontal autoscaling behaviors across multiple instance configurations and service level objective (SLO) thresholds.

Result: Storage-related faults generate the largest cost overhead (up to $258 monthly under horizontal scaling), while routing anomalies consistently bias autoscalers toward insufficient resource allocation. Horizontal autoscaling exhibits greater susceptibility to transient anomalies, particularly near threshold boundaries.

Conclusion: The empirical insights offer actionable recommendations for designing fault-tolerant autoscaling policies that can distinguish genuine workload fluctuations from failure artifacts.

Abstract: Resource autoscaling mechanisms in cloud environments depend on accurate performance metrics to make optimal provisioning decisions. When infrastructure faults including hardware malfunctions, network disruptions, and software anomalies corrupt these metrics, autoscalers may systematically over- or under-provision resources, resulting in elevated operational expenses or degraded service reliability. This paper conducts controlled simulation experiments to measure how four prevalent fault categories affect both vertical and horizontal autoscaling behaviors across multiple instance configurations and service level objective (SLO) thresholds. Experimental findings demonstrate that storage-related faults generate the largest cost overhead, adding up to $258 monthly under horizontal scaling policies, whereas routing anomalies consistently bias autoscalers toward insufficient resource allocation. The sensitivity to fault-induced metric distortions differs markedly between scaling strategies: horizontal autoscaling exhibits greater susceptibility to transient anomalies, particularly near threshold boundaries. These empirically-grounded insights offer actionable recommendations for designing fault-tolerant autoscaling policies that distinguish genuine workload fluctuations from failure artifacts.

</details>


### [5] [Cognitive Infrastructure: A Unified DCIM Framework for AI Data Centers](https://arxiv.org/abs/2601.04750)
*Krishna Chaitanya Sunkara*

Main category: cs.DC

TL;DR: DCIM 3.0 is a unified AI framework for next-generation data center management integrating semantic reasoning, predictive analytics, autonomous orchestration, and unified connectivity.


<details>
  <summary>Details</summary>
Motivation: Address critical challenges in infrastructure automation, sustainability, and digital-twin design for next-generation AI data centers.

Method: Integrates knowledge graph-based intelligence, thermal modeling, and Unified Device Connectivity Protocol (UDCP) for semantic reasoning, predictive analytics, autonomous orchestration, and unified connectivity.

Result: Presents DCIM 3.0 as a comprehensive framework for AI data center management, though specific performance metrics are not provided in the abstract.

Conclusion: DCIM 3.0 provides a unified framework for next-generation AI data center management addressing automation, sustainability, and digital-twin challenges through integrated intelligence systems.

Abstract: This work presents DCIM 3.0, a unified framework integrating semantic reasoning, predictive analytics, autonomous orchestration, and unified connectivity for next-generation AI data center management. The framework addresses critical challenges in infrastructure automation, sustainability, and digital-twin design through knowledge graph-based intelligence, thermal modeling, and the Unified Device Connectivity Protocol (UDCP).Keywords-Data Center Infrastructure Management, DCIM, AI Data Centers, Knowledge Graphs, Digital Twin, Thermal Management, Infrastructure Automation, Sustainability, GPU Computing, Data Center

</details>


### [6] [Proof of Commitment: A Human-Centric Resource for Permissionless Consensus](https://arxiv.org/abs/2601.04813)
*Homayoun Maleki,Nekane Sainz,Jon Legarda*

Main category: cs.DC

TL;DR: Proof of Commitment (PoCmt) introduces a new consensus primitive based on non-parallelizable human engagement as a scarce resource, enforcing linear Sybil costs through time-sensitive human challenges, unlike parallelizable resources like computation or capital.


<details>
  <summary>Details</summary>
Motivation: Existing permissionless consensus protocols (Proof of Work, Proof of Stake) use parallelizable resources (computation, capital) that can be subdivided across identities at negligible marginal cost, making linear Sybil cost fundamentally unattainable. There's a need for a consensus mechanism that enforces proportional human-time effort for Sybil resistance.

Method: PoCmt uses real-time human engagement as a non-parallelizable resource. Validators maintain commitment state tracking cumulative human effort, protocol participation, and online availability. A Human Challenge Oracle issues identity-bound, time-sensitive challenges that limit the number of challenges solvable within each human window, making engagement non-parallelizable.

Result: Theoretical analysis shows PoCmt achieves a strictly linear Sybil cost profile (unlike zero marginal cost with parallelizable resources). Using weighted-backbone analysis, PoCmt achieves safety, liveness, and commitment-proportional fairness under partial synchrony. Simulations confirm human-time capacity as the sole adversarial bottleneck and validate commitment drift and fairness properties.

Conclusion: PoCmt represents a new point in consensus design space, grounding permissionless security in sustained human effort rather than computation or capital. It provides a fundamental cost-theoretic separation from existing paradigms by making Sybil attacks require proportional human-time investment.

Abstract: Permissionless consensus protocols require a scarce resource to regulate leader election and provide Sybil resistance. Existing paradigms such as Proof of Work and Proof of Stake instantiate this scarcity through parallelizable resources like computation or capital. Once acquired, these resources can be subdivided across many identities at negligible marginal cost, making linear Sybil cost fundamentally unattainable.
  We introduce Proof of Commitment (PoCmt), a consensus primitive grounded in a non-parallelizable resource: real-time human engagement. Validators maintain a commitment state capturing cumulative human effort, protocol participation, and online availability. Engagement is enforced through a Human Challenge Oracle that issues identity-bound, time-sensitive challenges, limiting the number of challenges solvable within each human window.
  Under this model, sustaining multiple active identities requires proportional human-time effort. We establish a cost-theoretic separation showing that protocols based on parallelizable resources admit zero marginal Sybil cost, whereas PoCmt enforces a strictly linear cost profile. Using a weighted-backbone analysis, we show that PoCmt achieves safety, liveness, and commitment-proportional fairness under partial synchrony.
  Simulations complement the analysis by isolating human-time capacity as the sole adversarial bottleneck and validating the predicted commitment drift and fairness properties. These results position PoCmt as a new point in the consensus design space, grounding permissionless security in sustained human effort rather than computation or capital.

</details>


### [7] [Asynchronous Secure Federated Learning with Byzantine aggregators](https://arxiv.org/abs/2601.04930)
*Antonella Del Pozzo,Achille Desreumaux,Mathieu Gestin,Alexandre Rapetti,Sara Tucci-Piergiovanni*

Main category: cs.DC

TL;DR: Privacy-preserving federated averaging with malicious aggregators in asynchronous settings using secure aggregation, differential privacy, and replicated servers without consensus.


<details>
  <summary>Details</summary>
Motivation: To address privacy risks in federated learning with malicious aggregators in asynchronous communication settings, where existing solutions don't handle Byzantine aggregators or asynchronous challenges effectively.

Method: Proposes replicated aggregators to tolerate malicious behavior, client-side masking with Gaussian noise for differential privacy, and an inclusion mechanism for uniform client participation in asynchronous settings without requiring consensus between aggregators.

Result: Maintains same performance as state-of-the-art across all metrics while providing privacy protection against malicious aggregators in asynchronous environments.

Conclusion: The solution successfully addresses privacy preservation in federated averaging with malicious aggregators in asynchronous settings, overcoming consensus impossibility and ensuring training liveness even with misbehaving aggregators.

Abstract: Privacy-preserving federated averaging is a central approach for protecting client privacy in federated learning. In this paper, we study this problem in an asynchronous communications setting with malicious aggregators. We propose a new solution to provide federated averaging in this model while protecting the client's data privacy through secure aggregation and differential privacy. Our solution maintains the same performance as the state of the art across all metrics. The main contributions of this paper are threefold. First, unlike existing single- or multi-server solutions, we consider malicious aggregation servers that may manipulate the model to leak clients' data or halt computation. To tolerate this threat, we replicate the aggregators, allowing a fraction of them to be corrupted. Second, we propose a new privacy preservation protocol for protocols in asynchronous communication models with Byzantine aggregators. In this protocol, clients mask their values and add Gaussian noise to their models. In contrast with previous works, we use the replicated servers to unmask the models, while ensuring the liveness of training even if aggregators misbehave. Third, the asynchronous communication model introduces new challenges not present in existing approaches. In such a setting, faster clients may contribute more frequently, potentially reducing their privacy and biasing the training. To address this, we introduce an inclusion mechanism that ensures uniform client participation and balanced privacy budgets. Interestingly, the solution presented in this paper does not rely on agreement between aggregators. Thus, we circumvent the known impossibility of consensus in asynchronous settings where processes might crash. Additionally, this feature increases availability, as a consensus-based algorithm only progresses in periods of low latency.

</details>


### [8] [Nalar: An agent serving framework](https://arxiv.org/abs/2601.05109)
*Marco Laju,Donghyun Son,Saurabh Agarwal,Nitin Kedia,Myungjin Lee,Jayanth Srinivasa,Aditya Akella*

Main category: cs.DC

TL;DR: Nalar is a new agent-serving framework that separates workflow specification from execution, enabling efficient serving of LLM-driven agentic applications with significant performance improvements over existing approaches.


<details>
  <summary>Details</summary>
Motivation: LLM-driven agentic applications face serving challenges due to heterogeneous components, dynamic control flow, long-running state, and unpredictable latencies. Existing solutions don't adequately address these issues while maintaining developer productivity.

Method: Nalar uses auto-generated Python stubs turning agent/tool invocations into futures with metadata, a managed state layer decoupling logical from physical state, and a two-level control architecture combining global policy computation with local event-driven enforcement.

Result: Across three agentic workloads, Nalar reduces tail latency by 34-74%, achieves up to 2.9× speedups, sustains 80 RPS where baselines fail, and scales to 130K futures with sub-500ms control overhead.

Conclusion: Nalar provides a scalable, efficient, and policy-driven framework for serving heterogeneous agentic applications without burdening developers with orchestration logic, addressing key challenges in LLM-driven agent serving.

Abstract: LLM-driven agentic applications increasingly automate complex, multi-step tasks, but serving them efficiently remains challenging due to heterogeneous components, dynamic and model-driven control flow, long-running state, and unpredictable latencies. Nalar is a ground-up agent-serving framework that cleanly separates workflow specification from execution while providing the runtime visibility and control needed for robust performance. Nalar preserves full Python expressiveness, using lightweight auto-generated stubs that turn agent and tool invocations into futures carrying dependency and context metadata. A managed state layer decouples logical state from physical placement, enabling safe reuse, migration, and consistent retry behavior. A two-level control architecture combines global policy computation with local event-driven enforcement to support adaptive routing, scheduling, and resource management across evolving workflows. Together, these mechanisms allow Nalar to deliver scalable, efficient, and policy-driven serving of heterogeneous agentic applications without burdening developers with orchestration logic. Across three agentic workloads, Nalar cuts tail latency by 34--74\%, achieves up to $2.9\times$ speedups, sustains 80 RPS where baselines fail, and scales to 130K futures with sub-500 ms control overhead.

</details>


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [9] [Memory-Guided Unified Hardware Accelerator for Mixed-Precision Scientific Computing](https://arxiv.org/abs/2601.04476)
*Chuanzhen Wang,Leo Zhang,Eric Liu*

Main category: cs.AR

TL;DR: A unified hardware accelerator framework for mixed-precision scientific computing that addresses limitations in finite element methods, spiking neural networks, and sparse tensor operations through memory-guided adaptation and automated optimization techniques.


<details>
  <summary>Details</summary>
Motivation: Existing specialized accelerators have fundamental limitations: finite element methods lack adaptive precision for varying numerical conditioning, spiking neural network accelerators can't handle non-spike operations and suffer from bit-width escalation, and FPGA tensor accelerators require manual configuration for sparsity patterns and only optimize dense computations.

Method: Introduces Memory-Guided Unified Hardware Accelerator with three enhanced modules: 1) memory-guided precision selection for adaptive numerical conditioning, 2) experience-driven bit-width management and dynamic parallelism adaptation for spiking neural networks, and 3) curriculum learning for automatic sparsity pattern discovery in sparse tensor operations.

Result: Extensive experiments show 2.8% improvement in numerical accuracy, 47% throughput increase, 34% energy reduction, and 45-65% throughput improvement compared to specialized accelerators across FEniCS, COMSOL, ANSYS benchmarks, MNIST, CIFAR-10, CIFAR-100, DVS-Gesture, and COCO 2017 datasets.

Conclusion: The framework enables unified processing of finite element methods, spiking neural networks, and sparse computations on a single platform while eliminating data transfer overhead between separate units, providing significant performance and efficiency gains over specialized accelerators.

Abstract: Recent hardware acceleration advances have enabled powerful specialized accelerators for finite element computations, spiking neural network inference, and sparse tensor operations. However, existing approaches face fundamental limitations: (1) finite element methods lack comprehensive rounding error analysis for reduced-precision implementations and use fixed precision assignment strategies that cannot adapt to varying numerical conditioning; (2) spiking neural network accelerators cannot handle non-spike operations and suffer from bit-width escalation as network depth increases; and (3) FPGA tensor accelerators optimize only for dense computations while requiring manual configuration for each sparsity pattern. To address these challenges, we introduce \textbf{Memory-Guided Unified Hardware Accelerator for Mixed-Precision Scientific Computing}, a novel framework that integrates three enhanced modules with memory-guided adaptation for efficient mixed-workload processing on unified platforms. Our approach employs memory-guided precision selection to overcome fixed precision limitations, integrates experience-driven bit-width management and dynamic parallelism adaptation for enhanced spiking neural network acceleration, and introduces curriculum learning for automatic sparsity pattern discovery. Extensive experiments on FEniCS, COMSOL, ANSYS benchmarks, MNIST, CIFAR-10, CIFAR-100, DVS-Gesture datasets, and COCO 2017 demonstrate 2.8\% improvement in numerical accuracy, 47\% throughput increase, 34\% energy reduction, and 45-65\% throughput improvement compared to specialized accelerators. Our work enables unified processing of finite element methods, spiking neural networks, and sparse computations on a single platform while eliminating data transfer overhead between separate units.

</details>


### [10] [MPM-LLM4DSE: Reaching the Pareto Frontier in HLS with Multimodal Learning and LLM-Driven Exploration](https://arxiv.org/abs/2601.04801)
*Lei Xu,Shanshan Wang,Chenglong Xiao*

Main category: cs.AR

TL;DR: MPM-LLM4DSE framework uses multimodal prediction (fusing behavioral descriptions and flow graphs) and LLM-based optimization with pragma impact analysis for HLS design space exploration, achieving significant improvements over existing methods.


<details>
  <summary>Details</summary>
Motivation: Existing GNN-based prediction methods don't fully capture semantic features in behavioral descriptions, and conventional multi-objective optimization algorithms lack explicit domain knowledge about how pragma directives affect quality of results.

Method: Proposes MPM-LLM4DSE framework with: 1) Multimodal prediction model (MPM) that fuses features from behavioral descriptions and control/data flow graphs, 2) LLM as optimizer with tailored prompt engineering methodology incorporating pragma impact analysis on QoR.

Result: Multimodal predictive model outperforms state-of-the-art ProgSG by up to 10.25×. In DSE tasks, LLM4DSE achieves average 39.90% performance gain over prior methods.

Conclusion: The proposed framework effectively addresses limitations of existing methods by combining multimodal feature fusion with LLM-based optimization guided by domain-specific pragma impact knowledge, significantly improving HLS design space exploration.

Abstract: High-Level Synthesis (HLS) design space exploration (DSE) seeks Pareto-optimal designs within expansive pragma configuration spaces. To accelerate HLS DSE, graph neural networks (GNNs) are commonly employed as surrogates for HLS tools to predict quality of results (QoR) metrics, while multi-objective optimization algorithms expedite the exploration. However, GNN-based prediction methods may not fully capture the rich semantic features inherent in behavioral descriptions, and conventional multi-objective optimization algorithms often do not explicitly account for the domain-specific knowledge regarding how pragma directives influence QoR. To address these limitations, this paper proposes the MPM-LLM4DSE framework, which incorporates a multimodal prediction model (MPM) that simultaneously fuses features from behavioral descriptions and control and data flow graphs. Furthermore, the framework employs a large language model (LLM) as an optimizer, accompanied by a tailored prompt engineering methodology. This methodology incorporates pragma impact analysis on QoR to guide the LLM in generating high-quality configurations (LLM4DSE). Experimental results demonstrate that our multimodal predictive model significantly outperforms state-of-the-art work ProgSG by up to 10.25$\times$. Furthermore, in DSE tasks, the proposed LLM4DSE achieves an average performance gain of 39.90\% over prior methods, validating the effectiveness of our prompting methodology. Code and models are available at https://github.com/wslcccc/MPM-LLM4DSE.

</details>


### [11] [Challenges and Research Directions for Large Language Model Inference Hardware](https://arxiv.org/abs/2601.05047)
*Xiaoyu Ma,David Patterson*

Main category: cs.AR

TL;DR: This paper identifies memory and interconnect as primary challenges for LLM inference, proposing four architecture solutions: High Bandwidth Flash, Processing-Near-Memory, 3D memory-logic stacking, and low-latency interconnect.


<details>
  <summary>Details</summary>
Motivation: LLM inference faces unique challenges due to the autoregressive Decode phase of Transformer models, with memory and interconnect bottlenecks becoming more critical than compute, especially given recent AI trends.

Method: The paper proposes four architectural research opportunities: 1) High Bandwidth Flash for 10X memory capacity with HBM-like bandwidth, 2) Processing-Near-Memory for high memory bandwidth, 3) 3D memory-logic stacking, and 4) low-latency interconnect to speed up communication.

Result: The paper identifies key architectural bottlenecks in LLM inference and proposes specific hardware solutions to address memory capacity, bandwidth, and communication latency challenges.

Conclusion: Architecture innovations in memory systems and interconnects are crucial for efficient LLM inference, with proposed solutions applicable to both datacenter AI and mobile devices.

Abstract: Large Language Model (LLM) inference is hard. The autoregressive Decode phase of the underlying Transformer model makes LLM inference fundamentally different from training. Exacerbated by recent AI trends, the primary challenges are memory and interconnect rather than compute. To address these challenges, we highlight four architecture research opportunities: High Bandwidth Flash for 10X memory capacity with HBM-like bandwidth; Processing-Near-Memory and 3D memory-logic stacking for high memory bandwidth; and low-latency interconnect to speedup communication. While our focus is datacenter AI, we also review their applicability for mobile devices.

</details>
